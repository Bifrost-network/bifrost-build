diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfdd.c quagga-0.99.9-bfd-0.90.1/bfdd/bfdd.c
--- quagga-0.99.9/bfdd/bfdd.c	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfdd.c	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,722 @@
+/*
+ * BFDD - bfdd.c
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include <zebra.h>
+
+#include "thread.h"
+#include "vty.h"
+#include "command.h"
+#include "log.h"
+#include "memory.h"
+#include "linklist.h"
+#include "if.h"
+#include "hash.h"
+#include "stream.h"
+#include "prefix.h"
+#include "table.h"
+#include "privs.h"
+#include "sockopt.h"
+#include "sockunion.h"
+#include "zclient.h"
+
+#include "bfd.h"
+#include "bfdd/bfdd.h"
+#include "bfdd/bfd_fsm.h"
+#include "bfdd/bfd_debug.h"
+#include "bfdd/bfd_zebra.h"
+#include "bfdd/bfd_interface.h"
+#include "bfdd/bfd_packet.h"
+#include "bfdd/bfd_net.h"
+
+extern struct zclient *zclient;
+
+struct bfd_lport *bfd_lport;
+struct neightbl *neightbl;
+struct bfd *bfd = NULL;
+uint32_t mydisc = 0;
+
+
+/* Create a new BFD structure */
+static void
+bfd_new (void)
+{
+  bfd = XCALLOC (MTYPE_BFD, sizeof (struct bfd));
+  bfd->sock4_1hop = bfd_server_socket_init (AF_INET, BFD_PORT_1HOP);
+  bfd->sock4_mhop = bfd_server_socket_init (AF_INET, BFD_PORT_MHOP);
+  bfd->sock4_1hop_echo = bfd_server_socket_init (AF_INET, BFD_PORT_1HOP_ECHO);
+#ifdef HAVE_IPV6
+  bfd->sock6_1hop = bfd_server_socket_init (AF_INET6, BFD_PORT_1HOP);
+  bfd->sock6_mhop = bfd_server_socket_init (AF_INET6, BFD_PORT_MHOP);
+  bfd->sock6_1hop_echo =
+    bfd_server_socket_init (AF_INET6, BFD_PORT_1HOP_ECHO);
+#endif /* HAVE_IPV6 */
+
+  /* Set up queue for waiting neighbors */
+  bfd->wqueue = list_new ();
+  bfd->debug = 0;		/* No debug by default */
+}
+
+/* Init BFD address header tree structure */
+static struct bfd_addrtreehdr *
+bfd_addrtreehdr_init (void)
+{
+  struct bfd_addrtreehdr *addrtreehdr =
+    XMALLOC (MTYPE_BFD_ADDRTREEHDR, sizeof (struct bfd_addrtreehdr));
+  addrtreehdr->count = 0;
+  addrtreehdr->info = route_table_init ();
+  return addrtreehdr;
+}
+
+/* Free BFD address header tree structure */
+static void
+bfd_addrtreehdr_free (struct bfd_addrtreehdr *hdrp)
+{
+  XFREE (MTYPE_BFD_ADDRTREEHDR, hdrp);
+}
+
+
+/* Makes my discriminator hash (part of neighbor database) */
+static uint32_t
+bfd_mydischash_make (void *np)
+{
+  return ((struct bfd_neigh *) np)->ldisc;
+}
+
+/* If two cneigh have same values then return 1 else return 0. */
+static int
+bfd_mydischash_neigh_cmp (void *np1, void *np2)
+{
+  struct bfd_neigh *neighp1 = (struct bfd_neigh *) np1;
+  struct bfd_neigh *neighp2 = (struct bfd_neigh *) np2;
+
+  if (neighp1 == NULL && neighp2 == NULL)
+    return 1;
+  if (neighp1 == NULL || neighp2 == NULL)
+    return 0;
+
+  if (neighp1->ldisc == neighp2->ldisc)
+    return 1;
+  else
+    return 0;
+}
+
+/* Compare neighbors based on local and remote addresses */
+static int
+bfd_neigh_cmp (struct bfd_neigh *neighp1, struct bfd_neigh *neighp2)
+{
+  int ret;
+
+  ret = sockunion_cmp (neighp1->su_local, neighp2->su_local);
+  if (ret)
+    return ret;
+
+  ret = sockunion_cmp (neighp1->su_remote, neighp2->su_remote);
+  if (ret)
+    return ret;
+
+  return 0;
+}
+
+/* 
+   Neighbors' (sessions') database diagram
+
+   struct neightbl_________
+   |struct neighstruct *v4 |---> struct neighstruct________
+   |struct neighstruct *v6 |     |struct route_table *raddr|--->N
+   |struct hash *ldisc     |-\   |_________________________|   / \
+   |_______________________| |                                N   N
+                             |                               / \ / \
+                             |                              |
+     /-----------------------/                              V     [node]
+     |                                                      struct route_node
+     |                       struct bfd_addrtreehdr____ <---|void *info     |
+     |                       |int count                |    |...            |
+     |                 S<----|struct route_table *info |    |_______________|
+     |                / \    |_________________________|
+     |               S   S
+     |              / \ / \
+     |                     |
+     |                     V   [subnode]
+     V                     struct route_node
+     struct bfd_neigh <----|void *info     |
+     |...           |      |...            |
+     |______________|      |_______________|
+*/
+
+/* Initialization of neighbors' table */
+static void
+bfd_neightbl_init (void)
+{
+  neightbl = XMALLOC (MTYPE_BFD_NEIGHTBL, sizeof (struct neightbl));
+
+  neightbl->ldisc =
+    hash_create_size (BFD_NEIGH_HASH_SIZE, bfd_mydischash_make,
+		      bfd_mydischash_neigh_cmp);
+  neightbl->v4 = XMALLOC (MTYPE_BFD_NEIGHSTRUCT, sizeof (struct neighstruct));
+  neightbl->v4->raddr = route_table_init ();
+#ifdef HAVE_IPV6
+  neightbl->v6 = XMALLOC (MTYPE_BFD_NEIGHSTRUCT, sizeof (struct neighstruct));
+  neightbl->v6->raddr = route_table_init ();
+#endif /* HAVE_IPV6 */
+}
+
+/* Initialize local port structure responsible 
+   for delivery of unique port numbers */
+static void
+bfd_lport_init (void)
+{
+  bfd_lport = XMALLOC (MTYPE_BFD_LPORT, sizeof (struct bfd_lport));
+  bfd_lport->v4 = BFD_SOURCEPORT_MIN - 1;
+  bfd_lport->v6 = BFD_SOURCEPORT_MIN - 1;
+}
+
+/* Startup initialization */
+void
+bfd_init (void)
+{
+  bfd_new ();
+
+  bfd_neightbl_init ();
+  bfd_lport_init ();
+
+  /* Start listening for incoming BFD CP */
+  BFD_READ_ON (bfd->t_read4_1hop, bfd_read4_1hop, bfd->sock4_1hop);
+  BFD_READ_ON (bfd->t_read4_mhop, bfd_read4_mhop, bfd->sock4_mhop);
+
+#ifdef HAVE_IPV6
+  BFD_READ_ON (bfd->t_read6_1hop, bfd_read6_1hop, bfd->sock6_1hop);
+  BFD_READ_ON (bfd->t_read6_mhop, bfd_read6_mhop, bfd->sock6_mhop);
+#endif /* HAVE_IPV6 */
+}
+
+/* Get unique local discriminator */
+static uint32_t
+bfd_get_mydisc (void)
+{
+  if (mydisc == 0)
+    mydisc++;
+  return mydisc++;
+}
+
+static uint32_t
+bfd_xmitauthseq_init (void)
+{
+  return rand () % UINT32_MAX;
+}
+
+
+/* Do initialization of bfd_neigh structure based on the data from candidate */
+struct bfd_neigh *
+bfd_neigh_init (struct bfd_cneigh *cneighp)
+{
+  struct bfd_neigh *neighp =
+    XMALLOC (MTYPE_BFD_NEIGH, sizeof (struct bfd_neigh));
+
+  /* Local and Remote session state */
+  neighp->lstate = BFD_STATE_DOWN;	/* "MUST be initialized to Down." */
+  neighp->rstate = BFD_STATE_DOWN;	/* "MUST be initialized to Down." */
+  /* Local and Remote discriminators */
+  neighp->ldisc = bfd_get_mydisc ();	/* Get unique local discriminator */
+  neighp->rdisc = 0;		/* "MUST be initialized to zero." */
+
+  /* Local and remote diagnostic 
+     "This MUST be initialized to zero (No Diagnostic.)" */
+  neighp->ldiag = BFD_DIAG_NODIAG;
+  neighp->rdiag = BFD_DIAG_NODIAG;
+
+  /* Intervals
+     "This MUST be initialized to a value of 
+     at least one second (1,000,000 microseconds)" */
+  neighp->ldesmintx = BFD_LDESMINTX_DFT;
+  neighp->ldesmintx_a = BFD_LDESMINTX_DFT;
+  /* This variable MUST be initialized to 1." */
+  neighp->rreqminrx = BFD_RREQMINRX_DFT;
+  neighp->negtxint = 0;
+  neighp->negrxint = 0;
+  neighp->txint = BFD_LDESMINTX_DFT;	/* for 1st xmitted pkt */
+
+  neighp->lreqminrx = BFD_LREQMINRX_DFT;
+  neighp->lreqminrx_a = BFD_LREQMINRX_DFT;
+  neighp->rdesmintx = BFD_RREQMINRX_DFT;
+
+  /* "If this value is zero, the transmitting system does 
+     not support the receipt of BFD Echo packets." */
+  neighp->lreqminechorx = BFD_REQMINECHORX_DFT;
+  neighp->rreqminechorx = BFD_REQMINECHORX_DFT;
+
+  neighp->lmulti = BFD_DFT_MULTI;
+  neighp->rmulti = BFD_DFT_MULTI;
+
+  neighp->dtime = 0;
+
+  /* Authentication - i.e. no authentication */
+  neighp->authtype = BFD_AUTH_NOAUTH;
+  neighp->xmitauthseq = bfd_xmitauthseq_init ();
+  neighp->authseqknown = 0;
+
+  neighp->llen = 0;
+  neighp->rlen = 0;
+  neighp->lver = 1;		/* Supported version of BFD */
+  neighp->rver = 1;
+
+  /* Local and remote BFD CP flags (bits) */
+  neighp->lbits = 0;
+  neighp->rbits = 0;
+
+  /* FSM status and old status
+     "Down state means that the session is down (or has just been created.)" */
+  neighp->status = FSM_S_Down;
+  neighp->ostatus = FSM_S_Down;
+
+  /* Timer threads */
+  neighp->t_timer = NULL;
+  neighp->t_hello = NULL;
+  neighp->t_session = NULL;
+  neighp->t_delete = NULL;
+
+  /* Use the same set of flags as candidate */
+  neighp->flags = cneighp->flags;
+  neighp->notify = 0;
+  neighp->del = 0;
+
+  neighp->ifindex = cneighp->ifindex;
+
+  neighp->sock = -1;
+  neighp->lport = 0;
+  neighp->su_local = hostprefix2sockunion (&cneighp->laddr);
+  neighp->su_remote = hostprefix2sockunion (&cneighp->raddr);
+
+  /* Statistics */
+  neighp->uptime = 0;
+  neighp->last_xmit = 0;
+  neighp->last_recv = 0;
+  neighp->xmit_cnt = 0;
+  neighp->recv_cnt = 0;
+  neighp->orecv_cnt = 0;
+  neighp->timer_cnt = 0;
+
+  return neighp;
+}
+
+static void
+bfd_neigh_free (struct bfd_neigh *neighp)
+{
+  if (neighp->sock > 0)
+    bfd_sockclose (neighp->sock);
+  sockunion_free (neighp->su_local);
+  sockunion_free (neighp->su_remote);
+  XFREE (MTYPE_BFD_NEIGH, neighp);
+}
+
+/* Create new neighbor(session) from given candidate neighbor */
+struct bfd_neigh *
+bfd_cneigh_to_neigh (struct bfd_cneigh *cneighp)
+{
+  struct bfd_neigh *neighp = bfd_neigh_init (cneighp);
+  return neighp;
+}
+
+/* Perform a lookup on neighbor table (database) using local/remote addresses
+   and optionally interface index as a key */
+struct bfd_neigh *
+bfd_find_neigh (struct prefix *raddr, struct prefix *laddr,
+		unsigned int ifindex)
+{
+  struct route_node *node, *subnode;
+  struct bfd_addrtreehdr *hdrp;
+  struct neighstruct *ns;
+
+  if (raddr->family == AF_INET)
+    ns = neightbl->v4;
+#ifdef HAVE_IPV6
+  else if (raddr->family == AF_INET6)
+    ns = neightbl->v6;
+#endif /* HAVE_IPV6 */
+  else
+    abort ();
+
+  if ((node = route_node_lookup (ns->raddr, raddr)))
+    {
+      /* Paranoia */
+      assert (node->info);
+      hdrp = (struct bfd_addrtreehdr *) node->info;
+      assert (hdrp->info);
+      assert (hdrp->count);
+
+      if ((subnode = route_node_lookup (hdrp->info, laddr)))
+	{
+	  if (ifindex)
+	    {
+	      if (((struct bfd_neigh *) subnode->info)->ifindex == ifindex)
+		return (struct bfd_neigh *) subnode->info;
+	      else
+		return NULL;
+	    }
+	  return (struct bfd_neigh *) subnode->info;
+	}
+    }
+  return NULL;
+}
+
+/* Lookup on neighbor database by neighbor 
+   (only laddr/raddr is used as a key)*/
+static struct bfd_neigh *
+bfd_neightbl_neigh_lookup (struct bfd_neigh *neighp)
+{
+  return bfd_find_neigh (sockunion2hostprefix (neighp->su_remote),
+			 sockunion2hostprefix (neighp->su_local), 0);
+}
+
+/* Do lookup on neighbor's wait queue to check if 
+   at least one neighbor with the same pair or local
+   and remote address waits for addition / removal 
+   to/from database. */
+static struct bfd_neigh *
+bfd_wqueue_lookup (struct bfd_neigh *neighp)
+{
+  struct listnode *node;
+  struct bfd_neigh *bnp;
+
+  if (list_isempty (bfd->wqueue))
+    return NULL;
+
+  for (ALL_LIST_ELEMENTS_RO (bfd->wqueue, node, bnp))
+    {
+      if (!bfd_neigh_cmp (bnp, neighp))
+	return bnp;
+    }
+  return NULL;
+}
+
+/* Big ugly function responsible for adding/removing neighbor from
+   neighbor's database using as a key remote, and as a subkey local address */
+static int
+bfd_neightbl_raddr_adddel (int cmd, struct bfd_neigh *neighp)
+{
+  struct route_node *node, *subnode;
+  struct bfd_addrtreehdr *hdrp;
+  struct neighstruct *ns;
+
+  struct prefix *raddr = sockunion2hostprefix (neighp->su_remote);
+  struct prefix *laddr = sockunion2hostprefix (neighp->su_local);
+
+  /* Select appropriate table(database) based on family */
+  if (PREFIX_FAMILY (raddr) == AF_INET)
+    ns = neightbl->v4;
+#ifdef HAVE_IPV6
+  else
+    ns = neightbl->v6;
+#endif /* HAVE_IPV6 */
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    {
+      char rpbuf[BUFSIZ];
+      char lpbuf[BUFSIZ];
+      prefix2str (raddr, rpbuf, sizeof (rpbuf));
+      prefix2str (laddr, lpbuf, sizeof (lpbuf));
+      zlog_debug ("%s: cmd=%s <raddr=%s, laddr=%s, ifindex=%d, flags=%d>\n",
+		  __func__, bfd_neigh_cmd_str[cmd], rpbuf, lpbuf,
+		  neighp->ifindex, neighp->flags);
+    }
+
+  /* Do first lookup based on remote IP address */
+  if ((node = route_node_lookup (ns->raddr, raddr)))
+    {
+      hdrp = (struct bfd_addrtreehdr *) node->info;
+      /* 2nd lookup based on local address */
+      if ((subnode = route_node_lookup (hdrp->info, laddr)))
+	{
+	  switch (cmd)
+	    {
+	    case BFD_NEIGH_ADD:
+	      if (BFD_IF_DEBUG_ZEBRA)
+		zlog_debug ("%s:(raddr) neighbor already exists", __func__);
+	      return BFD_ERR;	/* Neighbor already exists */
+	    case BFD_NEIGH_DEL:
+	      if (BFD_IF_DEBUG_ZEBRA)
+		zlog_debug ("%s:(raddr) removing subnode", __func__);
+
+	      subnode->info = NULL;	/* we will free neighbor later */
+	      subnode->lock = 0;
+	      route_node_delete (subnode);
+	      hdrp->count--;
+
+	      /* Check if any local address is attached to peer address, 
+	         if not remove the peer addr node */
+	      if (hdrp->count == 0)
+		{
+		  if (BFD_IF_DEBUG_ZEBRA)
+		    zlog_debug ("%s:(raddr) removing node", __func__);
+		  bfd_addrtreehdr_free (node->info);
+		  node->info = NULL;
+		  node->lock = 0;
+		  route_node_delete (node);
+		}
+	      return BFD_OK;
+	    }
+	}
+      else
+	{
+	  /* Neighbor already exists but a transport address (local binding) 
+	     is different */
+	  switch (cmd)
+	    {
+	    case BFD_NEIGH_ADD:
+	      if (BFD_IF_DEBUG_ZEBRA)
+		zlog_debug
+		  ("%s:(raddr) neighbor already exists but local "
+		   "binding is different - adding a new local address",
+		   __func__);
+	      hdrp = (struct bfd_addrtreehdr *) node->info;
+	      hdrp->count++;
+	      subnode = route_node_get (hdrp->info, laddr);	/* Add new laddr */
+	      subnode->info = neighp;
+	      return BFD_OK;
+	    case BFD_NEIGH_DEL:
+	      if (BFD_IF_DEBUG_ZEBRA)
+		zlog_debug
+		  ("%s:(raddr) unable to delete neighbor - laddr  not found",
+		   __func__);
+	    }
+	}
+    }
+  else
+    {
+      switch (cmd)
+	{
+	case BFD_NEIGH_ADD:
+	  if (BFD_IF_DEBUG_ZEBRA)
+	    zlog_debug ("%s:(raddr) adding new neighbor", __func__);
+	  node = route_node_get (ns->raddr, raddr);
+	  node->info = bfd_addrtreehdr_init ();
+	  hdrp = (struct bfd_addrtreehdr *) node->info;
+	  hdrp->count++;
+	  subnode = route_node_get (hdrp->info, laddr);
+	  subnode->info = neighp;
+	  return BFD_OK;
+	case BFD_NEIGH_DEL:
+	  if (BFD_IF_DEBUG_ZEBRA)
+	    zlog_debug ("%s:(raddr) unable to delete - neighbor not found",
+			__func__);
+	}
+    }
+  return BFD_ERR;
+}
+
+/* Add neighbor using local distriminator as a key to the database */
+static int
+bfd_neightbl_ldisc_add (struct bfd_neigh *neighp)
+{
+  struct bfd_neigh *find;
+
+  for (int i = 0; i < BFD_NEIGH_MAX; i++)
+    if ((find = (struct bfd_neigh *) hash_lookup (neightbl->ldisc, neighp)))
+      {
+	neighp->ldisc = bfd_get_mydisc ();
+	if (BFD_IF_DEBUG_ZEBRA)
+	  zlog_debug ("%s:(ldisc) Reassign: neighp->ldisc=%u\n", __func__,
+		      neighp->ldisc);
+      }
+    else
+      break;
+
+  find =
+    (struct bfd_neigh *) hash_get (neightbl->ldisc, neighp,
+				   hash_alloc_intern);
+  if (BFD_IF_DEBUG_ZEBRA)
+    zlog_debug ("%s:(ldisc) Assign: neighp->ldisc=%u\n", __func__,
+		neighp->ldisc);
+
+  return BFD_OK;
+}
+
+/* Remove local discrinator of given neighbor from the database (hash) */
+static int
+bfd_neightbl_ldisc_del (struct bfd_neigh *neighp)
+{
+  struct bfd_neigh *find;
+  struct bfd_neigh key, *ret;
+
+  key.ldisc = neighp->ldisc;
+
+  if ((find = (struct bfd_neigh *) hash_lookup (neightbl->ldisc, &key)))
+    {
+      ret = hash_release (neightbl->ldisc, find);
+      assert (ret != NULL);
+      if (BFD_IF_DEBUG_ZEBRA)
+	zlog_debug ("%s:(ldisc) Delete\n", __func__);
+      return 0;
+    }
+  else
+    abort ();
+}
+
+static int
+bfd_neigh_start (struct bfd_neigh *neighp)
+{
+  /* Create a socket */
+  bfd_sendsock_init (neighp);
+  /* Check if passive mode is desired, 
+     if yes wait for first step from the remote system */
+  bfd_neigh_if_passive_update (neighp);
+  if (!bfd_flag_passive_check (neighp))
+    bfd_fsm_neigh_add (neighp);
+  return BFD_OK;
+}
+
+/* Start neighbor but first check if everything is ok */
+static int
+bfd_neigh_trytostart (struct bfd_neigh *neighp)
+{
+  if (bfd_neigh_check (neighp))
+    {
+      if (BFD_IF_DEBUG_ZEBRA)
+	BFD_LOG_DEBUG_NEIGH_ARG ("%s: unable to start bfd session this time",
+				 __func__) return BFD_ERR;
+    }
+  if (BFD_IF_DEBUG_ZEBRA)
+    BFD_LOG_DEBUG_NEIGH_ARG ("%s: starting bfd session", __func__)
+      return bfd_neigh_start (neighp);
+}
+
+/* Add neighbor(newly created session) to the neighbor table(database). */
+static int
+bfd_neigh_db_add (struct bfd_neigh *neighp)
+{
+  if ((bfd_neightbl_raddr_add (neighp) < 0))
+    abort ();			/* Something went wrong... */
+  return bfd_neightbl_ldisc_add (neighp);
+}
+
+/* Add neighbor to database with conflict check to avoid
+   collision with existing neighbor */
+static int
+bfd_neigh_db_add_cc (struct bfd_neigh *neighp)
+{
+  struct bfd_neigh *find = bfd_neightbl_neigh_lookup (neighp);
+
+  /* Check if neighbor with the same laddr and raddr has been registered
+     - if yes (it was registered), check if delete flag is set. If flag is set  
+     it means that neighbor will be removed soon, if not we have inconsistency */
+  if (find)
+    {
+      if (find->del)
+	{
+	  /* Neighbor has to wait until a previous one with the same
+	     laddr/raddr pair will be deleted */
+	  listnode_add (bfd->wqueue, neighp);
+	  return 1;
+	}
+      else
+	{
+	  if (BFD_IF_DEBUG_ZEBRA)
+	    zlog_debug ("%s: neighbor exist but delete flag is not set!",
+			__func__);
+	  abort ();
+	}
+    }
+  else
+    /* If we didn't find anything we can proceed to add neighbor */
+    return bfd_neigh_db_add (neighp);
+}
+
+/* Candidate neighbor delete. Subroutine is called after receiving
+   corresponding message from zebra. Function will start removal 
+   process of bfd neighbor/session */
+int
+bfd_cneigh_del (struct bfd_cneigh *cneighp)
+{
+  struct bfd_neigh *neighp;
+
+  /* Do a neighbor lookup */
+  neighp =
+    bfd_find_neigh (&cneighp->raddr, &cneighp->laddr, cneighp->ifindex);
+  if (!neighp)
+    {
+      if (BFD_IF_DEBUG_ZEBRA)
+	BFD_ZEBRA_LOG_DEBUG_ARG ("%s: unable to find neighbor", __func__)
+	  return BFD_ERR;
+    }
+  return bfd_fsm_neigh_del (neighp);
+}
+
+/* Delete neighbor from database */
+static int
+bfd_neigh_db_del (struct bfd_neigh *neighp)
+{
+  /* Delete neighbor from database */
+  if (bfd_neightbl_raddr_del (neighp) < 0)
+    abort ();			/* Database inconsistency */
+  bfd_neightbl_ldisc_del (neighp);
+  return BFD_OK;
+}
+
+
+/* Delete neighbor. Function is called by fsm session's delete timer */
+int
+bfd_neigh_del (struct bfd_neigh *neighp)
+{
+  /* Check if any neighbor is waiting for this one to be deleted */
+  struct bfd_neigh *find = bfd_wqueue_lookup (neighp);
+
+  /* Remove neighbor from database */
+  bfd_neigh_db_del (neighp);
+
+  /* If we have waiting neighbor, remove it from waiting queue and 
+     give it an opportunity to start session */
+  if (find)
+    {
+      listnode_delete (bfd->wqueue, find);
+      bfd_neigh_db_add (find);
+      bfd_neigh_trytostart (find);
+    }
+  /* Delete unused neighbor permanently */
+  bfd_neigh_free (neighp);
+  return BFD_OK;
+}
+
+int
+bfd_neigh_add (struct bfd_neigh *neighp)
+{
+  /* Try to add neighbor to the database */
+  if (bfd_neigh_db_add_cc (neighp))
+    {
+      if (BFD_IF_DEBUG_ZEBRA)
+	BFD_LOG_DEBUG_NEIGH_ARG ("%s: neighbor addition is postponed",
+				 __func__) return BFD_ERR;
+    }
+  else
+    {
+      if (bfd_neigh_check (neighp))
+	{
+	  if (BFD_IF_DEBUG_ZEBRA)
+	    BFD_LOG_DEBUG_NEIGH_ARG
+	      ("%s: unable to start bfd session this time",
+	       __func__) return BFD_ERR;
+	}
+      else
+	{
+	  if (BFD_IF_DEBUG_ZEBRA)
+	    BFD_LOG_DEBUG_NEIGH_ARG ("%s: starting bfd session", __func__)
+	      return bfd_neigh_start (neighp);
+	}
+    }
+}
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfdd.conf.sample quagga-0.99.9-bfd-0.90.1/bfdd/bfdd.conf.sample
--- quagga-0.99.9/bfdd/bfdd.conf.sample	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfdd.conf.sample	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,13 @@
+!
+! BFDd sample configuratin file
+!
+! bfdd.conf
+!
+hostname bfdd
+password zebra
+!
+!log file zapd.log
+!
+log stdout
+!
+
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_debug.c quagga-0.99.9-bfd-0.90.1/bfdd/bfd_debug.c
--- quagga-0.99.9/bfdd/bfd_debug.c	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_debug.c	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,141 @@
+/*
+ * BFDD - bfd_debug.c   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include <zebra.h>
+#include "command.h"
+#include "zclient.h"
+#include "hash.h"
+#include "prefix.h"
+#include "table.h"
+
+#include "bfd.h"
+#include "bfdd/bfdd.h"
+#include "bfdd/bfd_debug.h"
+#include "bfdd/bfd_zebra.h"
+#include "bfdd/bfd_fsm.h"
+
+extern struct zclient *zclient;
+
+struct message bfd_status_msg[] = {
+  {0, "null"},
+  {FSM_S_AdminDown, "AdminDown"},
+  {FSM_S_Down, "Down"},
+  {FSM_S_Init, "Init"},
+  {FSM_S_Up, "Up"},
+};
+int bfd_status_msg_max = FSM_S_MAX;
+
+char *bfd_state_str[] = {
+  "AdminDown",
+  "Down",
+  "Init",
+  "Up",
+};
+
+char *bfd_neigh_cmd_str[] = {
+  NULL,
+  "BFD_NEIGH_ADD",
+  "BFD_NEIGH_DEL",
+};
+
+
+/* Debug node. */
+struct cmd_node debug_node = {
+  DEBUG_NODE,
+  "",
+  1
+};
+
+static int
+config_write_debug (struct vty *vty)
+{
+  int write = 0;
+  if (BFD_IF_DEBUG_ZEBRA)
+    {
+      vty_out (vty, "debug bfd zebra%s", VTY_NEWLINE);
+      write++;
+    }
+  if (BFD_IF_DEBUG_FSM)
+    {
+      vty_out (vty, "debug bfd fsm%s", VTY_NEWLINE);
+      write++;
+    }
+  return write;
+}
+
+DEFUN (show_debugging_bfd,
+       show_debugging_bfd_cmd,
+       "show debugging bfd", SHOW_STR DEBUG_STR BFD_STR)
+{
+  vty_out (vty, "BFD debugging status:%s", VTY_NEWLINE);
+  if (BFD_IF_DEBUG_ZEBRA)
+    vty_out (vty, "debug bfd zebra%s", VTY_NEWLINE);
+  if (BFD_IF_DEBUG_FSM)
+    vty_out (vty, "debug bfd fsm%s", VTY_NEWLINE);
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (debug_bfd_zebra,
+       debug_bfd_zebra_cmd,
+       "debug bfd zebra", DEBUG_STR BFD_STR "BFD and ZEBRA communication\n")
+{
+  bfd->debug |= BFD_DEBUG_ZEBRA;
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_debug_bfd_zebra,
+       no_debug_bfd_zebra_cmd,
+       "no debug bfd zebra",
+       NO_STR DEBUG_STR BFD_STR "BFD and ZEBRA communication\n")
+{
+  bfd->debug &= ~BFD_DEBUG_ZEBRA;
+  return CMD_SUCCESS;
+}
+
+DEFUN (debug_bfd_fsm,
+       debug_bfd_fsm_cmd, "debug bfd fsm", DEBUG_STR BFD_STR "BFD FSM\n")
+{
+  bfd->debug |= BFD_DEBUG_FSM;
+  return CMD_SUCCESS;
+}
+
+DEFUN (no_debug_bfd_fsm,
+       no_debug_bfd_fsm_cmd,
+       "no debug bfd fsm", NO_STR DEBUG_STR BFD_STR "BFD FSM\n")
+{
+  bfd->debug &= ~BFD_DEBUG_FSM;
+  return CMD_SUCCESS;
+}
+
+
+void
+bfd_vty_debug_init (void)
+{
+  install_node (&debug_node, config_write_debug);
+
+  install_element (ENABLE_NODE, &show_debugging_bfd_cmd);
+
+  install_element (ENABLE_NODE, &debug_bfd_zebra_cmd);
+  install_element (ENABLE_NODE, &no_debug_bfd_zebra_cmd);
+  install_element (ENABLE_NODE, &debug_bfd_fsm_cmd);
+  install_element (ENABLE_NODE, &no_debug_bfd_fsm_cmd);
+}
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_debug.h quagga-0.99.9-bfd-0.90.1/bfdd/bfd_debug.h
--- quagga-0.99.9/bfdd/bfd_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_debug.h	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,86 @@
+/*
+ * BFDD - bfd_debug.h   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef _QUAGGA_BFD_DEBUG_H
+#define _QUAGGA_BFD_DEBUG_H
+
+#include <zebra.h>
+#include "table.h"
+#include "vty.h"
+#include "hash.h"
+
+extern char *bfd_state_str[];
+extern char *bfd_neigh_cmd_str[];
+
+#define BFD_IF_DEBUG_ZEBRA (bfd->debug & BFD_DEBUG_ZEBRA)
+#define BFD_IF_DEBUG_FSM (bfd->debug & BFD_DEBUG_FSM)
+#define BFD_IF_DEBUG_NET (bfd->debug & BFD_DEBUG_NET)
+
+
+#define BFD_LOG_DEBUG_NEIGH_NOARG(format) \
+     zlog_debug(format \
+     " <local IP:%s disc:0x%08x(%d)<==>remote IP:%s disc:0x%08x(%d)>",        \
+     sockunion_su2str(neighp->su_local), neighp->ldisc, neighp->ldisc,        \
+     sockunion_su2str(neighp->su_remote), neighp->rdisc,neighp->rdisc);
+
+#define BFD_LOG_DEBUG_NEIGH_ARG(format, args...) \
+     zlog_debug(format \
+     " <local IP:%s disc:0x%08x(%d)<==>remote IP:%s disc:0x%08x(%d)>", ##args,\
+     sockunion_su2str(neighp->su_local), neighp->ldisc, neighp->ldisc,        \
+     sockunion_su2str(neighp->su_remote), neighp->rdisc,neighp->rdisc);
+
+#define BFD_ZEBRA_LOG_DEBUG_NOARG(format) \
+     { \
+       char rpbuf[BUFSIZ]; \
+       char lpbuf[BUFSIZ]; \
+       prefix2str(&cneighp->raddr,rpbuf,sizeof(rpbuf)); \
+       prefix2str(&cneighp->laddr,lpbuf,sizeof(lpbuf)); \
+       zlog_debug("[ZEBRA] " format \
+       " <raddr=%s, laddr=%s, ifindex=%d, flags=%d>", \
+        rpbuf, lpbuf, cneighp->ifindex, cneighp->flags);\
+     }
+
+#define BFD_ZEBRA_LOG_DEBUG_ARG(format, args...) \
+     { \
+     char rpbuf[BUFSIZ]; \
+     char lpbuf[BUFSIZ]; \
+     prefix2str(&cneighp->raddr,rpbuf,sizeof(rpbuf)); \
+     prefix2str(&cneighp->laddr,lpbuf,sizeof(lpbuf)); \
+     zlog_debug("[ZEBRA] " format \
+     " <raddr=%s, laddr=%s, ifindex=%d, flags=%d>", ##args,\
+      rpbuf, lpbuf, cneighp->ifindex, cneighp->flags); \
+     }
+
+#define BFD_FSM_LOG_DEBUG(format, args...) \
+     zlog_debug("[FSM] " format \
+     " <local IP:%s disc:0x%08x(%d)<==>remote IP:%s disc:0x%08x(%d)>", ##args,\
+     sockunion_su2str(neighp->su_local), neighp->ldisc, neighp->ldisc,        \
+     sockunion_su2str(neighp->su_remote), neighp->rdisc,neighp->rdisc);
+
+#define BFD_FSM_LOG_DEBUG_NOARG(format) \
+     zlog_debug("[FSM] " format \
+     " <local IP:%s disc:0x%08x(%d)<==>remote IP:%s disc:0x%08x(%d)>",        \
+     sockunion_su2str(neighp->su_local), neighp->ldisc, neighp->ldisc,        \
+     sockunion_su2str(neighp->su_remote), neighp->rdisc,neighp->rdisc);
+
+void bfd_vty_debug_init (void);
+
+#endif /* _QUAGGA_BFD_DEBUG_H */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfdd.h quagga-0.99.9-bfd-0.90.1/bfdd/bfdd.h
--- quagga-0.99.9/bfdd/bfdd.h	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfdd.h	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,258 @@
+/*
+ * BFDD - bfdd.h   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef _QUAGGA_BFDD_H
+#define _QUAGGA_BFDD_H
+
+#include <zebra.h>
+#include "linklist.h"
+#include "bfd.h"
+
+extern struct thread_master *master;
+extern struct bfd *bfd;
+extern struct neightbl *neightbl;
+
+#define BFDD_VERSION "0.90.1"
+
+#define BFDD_DEFAULT_CONFIG	"bfdd.conf"
+#define BFDD_VTY_PORT		2609
+
+#define BFD_PORT_1HOP		3784
+#define BFD_PORT_1HOP_ECHO	3785
+#define BFD_PORT_MHOP		4784
+
+#define BFD_SOURCEPORT_MIN	49152
+#define BFD_SOURCEPORT_MAX	65535
+
+				 /* 15sec */
+#define BFD_STIMEOUT		15000
+
+#define BFD_NEIGH_MAX		2048
+#define BFD_NEIGH_HASH_SIZE	BFD_NEIGH_MAX
+
+#define BFD_DEBUG_ZEBRA		(1<<0)
+#define BFD_DEBUG_FSM		(1<<1)
+#define BFD_DEBUG_NET		(1<<2)
+
+#define BFD_OK			0
+#define BFD_ERR			-1
+
+struct bfd
+{
+  struct list *iflist;		/* Interface list */
+  struct list *wqueue;		/* neighbor's wait queue */
+  uint32_t debug;		/* Debug flags */
+
+  /* Sockets */
+  int sock4_1hop;
+  int sock4_mhop;
+  int sock4_1hop_echo;
+
+  /* Threads serving sockets (incoming IPv4 packets) */
+  struct thread *t_read4_1hop;
+  struct thread *t_read4_mhop;
+  struct thread *t_read4_1hop_echo;
+#ifdef HAVE_IPV6
+  /* Sockets */
+  int sock6_1hop;
+  int sock6_mhop;
+  int sock6_1hop_echo;
+
+  /* Threads serving sockets (incoming IPv6 packets ) */
+  struct thread *t_read6_1hop;
+  struct thread *t_read6_mhop;
+  struct thread *t_read6_1hop_echo;
+#endif				/* HAVE_IPV6 */
+};
+
+struct neighstruct
+{
+  struct route_table *raddr;
+};
+
+struct neightbl
+{
+  struct hash *ldisc;
+  struct neighstruct *v4;
+#ifdef HAVE_IPV6
+  struct neighstruct *v6;
+#endif				/* HAVE_IPV6 */
+};
+
+struct bfd_addrtreehdr
+{
+  int count;			/* Number of nodes in radix tree */
+  struct route_table *info;	/* BFD subnode tree, 
+				   for storing local addr part of socket */
+};
+
+struct bfd_lport
+{
+  uint16_t v4;
+#ifdef HAVE_IPV6
+  uint16_t v6;
+#endif				/* HAVE_IPV6 */
+};
+
+struct bfd_neigh
+{
+  /* Sesion ID, state and diagnostic */
+  uint8_t lstate;		/* Local Session State */
+  uint8_t rstate;		/* Remote Session State */
+
+  uint8_t ldiag;		/* Local Diagnostic */
+  uint8_t rdiag;		/* Remote Diag */
+
+  uint32_t ldisc;		/* Local Discriminator */
+  uint32_t rdisc;		/* Remote Discriminator */
+
+  /* Timers */
+  uint32_t ldesmintx;		/* Local Desired Min Tx Interval */
+  uint32_t ldesmintx_a;		/* Local Desired Min Tx Interval advertised */
+  uint32_t rdesmintx;		/* Remote Desired Min Tx Interval */
+
+  uint32_t lreqminrx;		/* Local Required Min Rx Interval */
+  uint32_t lreqminrx_a;		/* Local Required Min Rx Interval advertised */
+  uint32_t rreqminrx;		/* Remote Required Min Rx Interval */
+
+  uint32_t negtxint;		/* Negotiated TX interval */
+  uint32_t negrxint;		/* Negotiated RX interval */
+  uint32_t txint;		/* Negotiated TX interval minus jitter */
+
+  uint32_t lreqminechorx;	/* Local  Required Min Echo RX Interval */
+  uint32_t rreqminechorx;	/* Remote Required Min Echo RX Interval */
+
+  uint8_t lmulti;		/* Local detect Multiplier */
+  uint8_t rmulti;		/* Remote detect Multiplier */
+
+  uint32_t dtime;		/* Detection Time */
+
+  /* Authentication */
+  uint8_t authtype;		/* Authentication Type */
+  uint32_t rcvauthseq;		/* Received Authentication Sequence */
+  uint32_t xmitauthseq;		/* Transmitted Authentication Sequence */
+  uint8_t authseqknown;		/* Authentication Sequence Known */
+
+  /* Packet info */
+  uint8_t llen;			/* Local packet length */
+  uint8_t rlen;			/* Remote packet length */
+  uint8_t lver;			/* Local  BFD CP version */
+  uint8_t rver;			/* Remote BFD CP version */
+
+  /* Bits (flags) */
+#define BFD_BIT_M  (1<<0)	/* Multipoint */
+#define BFD_BIT_D  (1<<1)	/* Demand */
+#define BFD_BIT_A  (1<<2)	/* Authentication Present */
+#define BFD_BIT_C  (1<<3)	/* Control Plane Independent */
+#define BFD_BIT_F  (1<<4)	/* Final */
+#define BFD_BIT_P  (1<<5)	/* Poll */
+  uint8_t lbits;		/* Local BFD bits (flags) */
+  uint8_t rbits;		/* Remote BFD bits (flags) */
+
+  /* FSM States */
+  int status;			/* FSM State */
+  int ostatus;			/* Old FSM State */
+
+  /* Threads */
+  struct thread *t_timer;	/* BFD FSM Timer (holdown) */
+  struct thread *t_hello;	/* BFD cntl pkt periodic transmission thread */
+  struct thread *t_session;	/* Session "timeout" (amount of time for which
+				   we maintain the session in "Down" state when 
+				   no BFD CP are received). When timer elapses session
+				   is cleared */
+  struct thread *t_delete;	/* Session delete timer (period of time that we xmit
+				   BFD control packets  with "AdminDown" state 
+				   after which neighbor(session) is removed */
+
+  /* Misc */
+  uint32_t flags;		/* Flags (do not confuse with bits from BFDCP).
+				   These flags contains requirements from BFD clients
+				   to bfd session. (e.g. 1HOP or MHOP, ASYNCH or DEMAND */
+  int notify;			/* Flag that indicates if FSM debug message was 
+				   logged already or not. Is used also for checking
+				   if notification about state change was send to zebra */
+  int del;			/* Flags that indicates that session started delete procedure */
+
+
+  /* Sockets and stuff */
+  int sock;			/* Socket */
+  uint16_t lport;		/* Local (source) port for BFDCP transmission */
+  unsigned int ifindex;		/* ifindex of the BFD connection. */
+  union sockunion *su_local;	/* Sockunion of local address.  */
+  union sockunion *su_remote;	/* Sockunion of remote address.  */
+
+  /* Statistics */
+  time_t uptime;		/* Up/Down state uptime  */
+  time_t last_xmit;		/* Time of last transmitted packet  */
+  time_t last_recv;		/* Time of last received packet  */
+  uint32_t xmit_cnt;		/* Total number of transmitted packets */
+  uint32_t recv_cnt;		/* Total number of received not discarded packets */
+  uint32_t orecv_cnt;		/* Snapshot of recv_cnt for session timeout detect. */
+  uint32_t timer_cnt;		/* Number of "TIMER" events */
+};
+
+#define BFD_TIMER_MSEC_ON(T,F,V) THREAD_TIMER_MSEC_ON(master,(T),(F),neighp,(V))
+#define BFD_TIMER_OFF(T) THREAD_TIMER_OFF(T)
+
+#define BFD_READ_ON(T,F,V) THREAD_READ_ON(master,T,F,bfd,V)
+
+#define bfd_check_neigh_family(NEIGHP) (((NEIGHP)->su_local)->sa.sa_family)
+
+/* Macros for checking local and remote flags */
+#define bfd_neigh_check_lbit_p(NEIGHP) ((((NEIGHP)->lbits) & BFD_BIT_P) ? 1 : 0)
+#define bfd_neigh_check_lbit_f(NEIGHP) ((((NEIGHP)->lbits) & BFD_BIT_F) ? 1 : 0)
+#define bfd_neigh_check_lbit_c(NEIGHP) ((((NEIGHP)->lbits) & BFD_BIT_C) ? 1 : 0)
+#define bfd_neigh_check_lbit_a(NEIGHP) ((((NEIGHP)->lbits) & BFD_BIT_A) ? 1 : 0)
+#define bfd_neigh_check_lbit_d(NEIGHP) ((((NEIGHP)->lbits) & BFD_BIT_D) ? 1 : 0)
+#define bfd_neigh_check_lbit_m(NEIGHP) ((((NEIGHP)->lbits) & BFD_BIT_M) ? 1 : 0)
+
+#define bfd_neigh_check_rbit_d(NEIGHP) ((((NEIGHP)->rbits) & BFD_BIT_D) ? 1 : 0)
+#define bfd_neigh_check_rbit_f(NEIGHP) ((((NEIGHP)->rbits) & BFD_BIT_F) ? 1 : 0)
+#define bfd_neigh_check_rbit_p(NEIGHP) ((((NEIGHP)->rbits) & BFD_BIT_P) ? 1 : 0)
+
+/* Packet legth */
+#define bfd_neigh_check_lplen(NEIGHP)  ((bfd_neigh_check_lbit_a(NEIGHP)) \
+					? BFD_PACKET_SIZE_AUTH \
+					: BFD_PACKET_SIZE_NOAUTH )
+
+
+void bfd_init (void);
+void bfd_cfg (void);
+
+struct bfd_neigh *bfd_neigh_init (struct bfd_cneigh *cneighp);
+
+struct bfd_neigh *bfd_cneigh_to_neigh (struct bfd_cneigh *cneighp);
+
+#define BFD_NEIGH_ADD    1
+#define BFD_NEIGH_DEL    2
+#define bfd_neightbl_raddr_add(NEIGHP) \
+  bfd_neightbl_raddr_adddel(BFD_NEIGH_ADD, NEIGHP)
+#define bfd_neightbl_raddr_del(NEIGHP) \
+  bfd_neightbl_raddr_adddel(BFD_NEIGH_DEL, NEIGHP)
+
+struct bfd_neigh *bfd_find_neigh (struct prefix *raddr, struct prefix *laddr,
+				  unsigned int ifindex);
+
+int bfd_neigh_add (struct bfd_neigh *neighp);
+int bfd_neigh_del (struct bfd_neigh *neighp);
+int bfd_cneigh_del (struct bfd_cneigh *cneighp);
+
+#endif /* _ZEBRA_BFD_H */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_fsm.c quagga-0.99.9-bfd-0.90.1/bfdd/bfd_fsm.c
--- quagga-0.99.9/bfdd/bfd_fsm.c	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_fsm.c	2007-10-21 01:31:07.000000000 +0200
@@ -0,0 +1,480 @@
+/*
+ * BFDD - bfd_fsm.c
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include <zebra.h>
+
+#include "log.h"
+#include "thread.h"
+#include "sockunion.h"
+
+#include "bfdd/bfdd.h"
+#include "bfdd/bfd_fsm.h"
+#include "bfdd/bfd_debug.h"
+#include "bfdd/bfd_interface.h"
+#include "bfdd/bfd_packet.h"
+#include "bfdd/bfd_zebra.h"
+
+extern struct message bfd_status_msg[];
+extern int bfd_status_msg_max;
+extern struct thread_master *master;
+
+/* BFD FSM timer aka liveness detection timer, it's responsibility
+   is to verify if our link partner is still alive */
+int
+bfd_fsm_timer (struct thread *thread)
+{
+  struct bfd_neigh *neighp;
+
+  neighp = THREAD_ARG (thread);
+  neighp->t_timer = NULL;
+
+  if (BFD_IF_DEBUG_FSM)
+    BFD_FSM_LOG_DEBUG_NOARG ("Timer expired")
+      /* If session transitioned from Up state because of "TIMER"
+         set corresponding diagnostic message */
+      if (neighp->status == FSM_S_Up)
+      {
+	neighp->ldiag = BFD_DIAG_TIMEEXPIRED;
+	neighp->timer_cnt++;
+      }
+
+  bfd_event (neighp, FSM_E_Timer);
+
+  return BFD_OK;
+}
+
+/* Session timeout timer, activated each time
+   when session goes into Down state. */
+int
+bfd_fsm_stimeout (struct thread *thread)
+{
+  struct bfd_neigh *neighp;
+
+  neighp = THREAD_ARG (thread);
+  neighp->t_session = NULL;
+
+  /* Check if session state is down and if it was any
+     activity since timer has been fired */
+  if ((neighp->status == FSM_S_Down)
+      && (neighp->orecv_cnt == neighp->recv_cnt))
+    {
+      /* There wasn't any activity our link neighbor 
+         is most probably dead or was administratively disabled */
+      if (BFD_IF_DEBUG_FSM)
+	BFD_FSM_LOG_DEBUG_NOARG ("Session timeout.")
+	  /* Reset "Your discriminator" */
+	  neighp->rdisc = 0;
+
+      /* Reset diagnostic */
+      neighp->ldiag = 0;
+
+      /* Reset timers to default values */
+      neighp->ldesmintx = BFD_LDESMINTX_DFT;
+      neighp->ldesmintx_a = BFD_LDESMINTX_DFT;
+      neighp->rreqminrx = BFD_RREQMINRX_DFT;
+      neighp->txint = BFD_LDESMINTX_DFT;
+
+      neighp->lreqminrx = BFD_LREQMINRX_DFT;
+      neighp->lreqminrx_a = BFD_LREQMINRX_DFT;
+      neighp->rdesmintx = BFD_RREQMINRX_DFT;
+
+      neighp->lreqminechorx = BFD_REQMINECHORX_DFT;
+      neighp->rreqminechorx = BFD_REQMINECHORX_DFT;
+
+      neighp->lmulti = BFD_DFT_MULTI;
+      neighp->rmulti = BFD_DFT_MULTI;
+
+      /* Clear flags (bits) */
+      neighp->lbits = 0;
+      neighp->rbits = 0;
+
+      neighp->notify = 0;
+
+      /* Update passive flag in case interface state has changed */
+      bfd_neigh_if_passive_update (neighp);
+      /* If passive mode is desired stop transmission of periodic BFDCP */
+      if (bfd_neigh_check_lbit_p (neighp))
+	BFD_TIMER_OFF (neighp->t_hello);
+    }
+  return BFD_OK;
+}
+
+/* Delete timer
+   If neighbor removal is requested by zebra (because 
+   of administrative purpose), we have to first signalize "AdminDown" 
+   state to our link partner and then we can start removing neighbor 
+   locally from our database. Delete timer represents time during which 
+   we transmit packets to the link neighbor with "AdminDown" state, 
+   once "bfd_fsm_delete" function is executed (after delete period)
+   session (neighbor) is removed permanently from database.
+ */
+static int
+bfd_fsm_delete (struct thread *thread)
+{
+  struct bfd_neigh *neighp;
+
+  neighp = THREAD_ARG (thread);
+  neighp->t_delete = NULL;
+
+  if (BFD_IF_DEBUG_FSM)
+    BFD_FSM_LOG_DEBUG_NOARG ("Removing neighbor")
+      BFD_TIMER_OFF (neighp->t_hello);
+  bfd_neigh_del (neighp);
+  return BFD_OK;
+}
+
+/* Fire hello thread for given neighbor */
+int
+bfd_fsm_neigh_add (struct bfd_neigh *neighp)
+{
+  if (BFD_IF_DEBUG_FSM)
+    zlog_debug ("[FSM] (%s) Add l:%s, r:%s/ldisc:%d, rdisc:%d", __func__,
+		sockunion_su2str (neighp->su_local),
+		sockunion_su2str (neighp->su_remote), neighp->ldisc,
+		neighp->rdisc);
+  BFD_TIMER_MSEC_ON (neighp->t_hello, bfd_pkt_xmit, BFD_TXINT (neighp));
+  return BFD_OK;
+}
+
+int
+bfd_fsm_neigh_del (struct bfd_neigh *neighp)
+{
+  if (BFD_IF_DEBUG_FSM)
+    zlog_debug ("[FSM] (%s) l:%s, r:%s/ldisc:%d, rdisc:%d", __func__,
+		sockunion_su2str (neighp->su_local),
+		sockunion_su2str (neighp->su_remote), neighp->ldisc,
+		neighp->rdisc);
+
+  /* Set delete flag */
+  neighp->del = 1;
+
+  /* Stop timers (session, timer) and schedule delete timer */
+  BFD_TIMER_OFF (neighp->t_timer);
+  BFD_TIMER_OFF (neighp->t_session);
+  BFD_TIMER_MSEC_ON (neighp->t_delete, bfd_fsm_delete,
+		     MSEC (neighp->negtxint * neighp->lmulti));
+
+  neighp->uptime = 0;
+
+  /* Change state to "AdminDown" */
+  bfd_event (neighp, FSM_E_Delete);
+
+  return BFD_OK;
+}
+
+/* Do nothing */
+static int
+bfd_fsm_ignore (struct bfd_neigh *neighp)
+{
+  if (BFD_IF_DEBUG_FSM)
+    BFD_FSM_LOG_DEBUG_NOARG ("ignoring packet") return BFD_OK;
+}
+
+static int
+bfd_fsm_discard (struct bfd_neigh *neighp)
+{
+  if (BFD_IF_DEBUG_FSM)
+    BFD_FSM_LOG_DEBUG_NOARG ("discarding packet") return BFD_ERR;
+}
+
+/* FSM Init state*/
+static int
+bfd_fsm_init (struct bfd_neigh *neighp)
+{
+  if ((neighp->notify != FSM_S_Init) && BFD_IF_DEBUG_FSM)
+    {
+      BFD_FSM_LOG_DEBUG_NOARG ("Init.") neighp->notify = FSM_S_Init;
+    }
+
+  neighp->lstate = BFD_STATE_INIT;
+
+  neighp->uptime = 0;
+
+  return BFD_OK;
+}
+
+/* FSM Up state */
+static int
+bfd_fsm_up (struct bfd_neigh *neighp)
+{
+
+  neighp->lstate = BFD_STATE_UP;
+
+  /* Check if session is Up on remote system */
+  if (neighp->rstate == BFD_STATE_UP)
+    {
+      struct bfd_if_info *bii = bfd_ifinfo_get (neighp);
+
+      if (neighp->notify != FSM_S_Up)
+	{
+	  if (BFD_IF_DEBUG_FSM)
+	    BFD_FSM_LOG_DEBUG_NOARG ("Up.") bfd_signal_neigh_up (neighp);
+	  neighp->notify = FSM_S_Up;
+	}
+
+      /* "If either bfd.DesiredMinTxInterval is changed 
+         or bfd.RequiredMinRxInterval is changed, a Poll Sequence 
+         MUST be initiated" - check also if we not already transmitting BFD CP
+         with a Final (F) bit set */
+      if (((neighp->ldesmintx != USEC (bii->interval)) ||
+	   (neighp->lreqminrx != USEC (bii->minrx))) &&
+	  !bfd_neigh_check_lbit_f (neighp))
+	{
+	  if (bfd_neigh_check_rbit_f (neighp))
+	    {
+	      neighp->ldesmintx = neighp->ldesmintx_a;
+	      neighp->lreqminrx = neighp->lreqminrx_a;
+
+	      neighp->negtxint =
+		neighp->rreqminrx >
+		neighp->ldesmintx ? neighp->rreqminrx : neighp->ldesmintx;
+	      /* Jitter */
+	      if (neighp->rmulti == 1)
+		neighp->txint = bfd_jtimer_mult_is1 (neighp->negtxint);
+	      else
+		neighp->txint = bfd_jtimer_mult_isnot1 (neighp->negtxint);
+	    }
+	  else
+	    {
+	      neighp->lbits |= BFD_BIT_P;
+	      neighp->ldesmintx_a = USEC (bii->interval);
+	      neighp->lreqminrx_a = USEC (bii->minrx);
+	    }
+	}
+      /* Refresh detect multiplier */
+      neighp->lmulti = bii->multiplier;
+
+      /* If demand mode is localy desired signalized it to neighbor */
+      if (bfd_flag_demand_check (neighp))
+	neighp->lbits |= BFD_BIT_D;
+
+      /* If check if neighbor wishes to run bfd is the demand mode */
+      if (bfd_neigh_check_rbit_d (neighp))
+	{
+	  /* If remote side has pulled us, and we want to send a 
+	     replay with "final" bit set - allow it. 
+	     Otherwise stop sending BFD control packets to neighbor */
+	  if (bfd_neigh_check_lbit_f (neighp))
+	    {
+	      neighp->t_hello = NULL;
+	      BFD_TIMER_MSEC_ON (neighp->t_hello, bfd_pkt_xmit,
+				 BFD_TXINT (neighp));
+	    }
+	  else
+	    BFD_TIMER_OFF (neighp->t_hello);
+	}
+
+      if (!neighp->uptime)
+	neighp->uptime = time (NULL);
+    }
+  return BFD_OK;
+}
+
+/* FSM AdminDown state */
+static int
+bfd_fsm_admdown (struct bfd_neigh *neighp)
+{
+  if ((neighp->notify != FSM_S_AdminDown) && BFD_IF_DEBUG_FSM)
+    {
+      BFD_FSM_LOG_DEBUG_NOARG ("AdminDown.") neighp->notify = FSM_S_AdminDown;
+
+      /* Send packet with admin down state immediately */
+      BFD_TIMER_OFF (neighp->t_hello);
+      BFD_TIMER_MSEC_ON (neighp->t_hello, bfd_pkt_xmit, 0);
+    }
+
+  /* If we undergo session removal process (delete flag set)
+     change signalised state to "AdminDown" and set appropriate
+     diagnostic message. Otherwise (i.e. if "del" not set) we
+     received a BFD CP with "AdminDown" state so we have to
+     signalize back "Down" state and corresponding diagnostic code. */
+
+  if (neighp->del)
+    {
+      neighp->lstate = BFD_STATE_ADMINDOWN;
+      neighp->ldiag = BFD_DIAG_ADMINDOWN;
+    }
+  else
+    {
+      neighp->lstate = BFD_STATE_DOWN;
+      neighp->ldiag = BFD_DIAG_SESSIONDOWN;
+    }
+
+  neighp->uptime = 0;
+
+  return BFD_OK;
+}
+
+
+/* FSM Down state */
+static int
+bfd_fsm_down (struct bfd_neigh *neighp)
+{
+
+  neighp->lstate = BFD_STATE_DOWN;
+
+  if (!neighp->uptime)
+    neighp->uptime = time (NULL);
+
+  /* Initialization of session timeout timer */
+  if (!neighp->t_session)
+    {
+      neighp->orecv_cnt = neighp->recv_cnt;
+      BFD_TIMER_MSEC_ON (neighp->t_session, bfd_fsm_stimeout,
+			 MSEC (neighp->dtime) + BFD_STIMEOUT);
+    }
+
+  /* If state is "Up" and we didn't notify zebra yet 
+     send notification about state transition to "Down" */
+  //if(neighp->status == FSM_S_Up && (neighp->notify != FSM_S_Down))
+  if (neighp->notify != FSM_S_Down)
+    {
+      BFD_FSM_LOG_DEBUG_NOARG ("Down.") neighp->notify = FSM_S_Down;
+      if (neighp->status == FSM_S_Up)
+	bfd_signal_neigh_down (neighp);
+    }
+  return BFD_OK;
+}
+
+/* BFD Finite State Machine structure
+
+                                  +--+
+                                  |  | UP, ADMIN DOWN, TIMER
+                                  |  V
+                          DOWN  +------+  INIT
+                   +------------|      |------------+
+                   |            | DOWN |            |
+                   |  +-------->|      |<--------+  |
+                   |  |         +------+         |  |
+                   |  |                          |  |
+                   |  |               ADMIN DOWN,|  |
+                   |  |ADMIN DOWN,          DOWN,|  |
+                   |  |TIMER                TIMER|  |
+                   V  |                          |  V
+                 +------+                      +------+
+            +----|      |                      |      |----+
+        DOWN|    | INIT |--------------------->|  UP  |    |INIT, UP
+            +--->|      | INIT, UP             |      |<---+
+                 +------+                      +------+
+*/
+struct
+{
+  int (*func) ();
+  int next_state;
+} FSM[FSM_S_MAX - 1][FSM_E_MAX - 1] =
+{
+  /* AdminDown  */
+  {
+    {
+    bfd_fsm_discard, FSM_S_AdminDown},	/* FSM_E_RecvAdminDown */
+    {
+    bfd_fsm_discard, FSM_S_AdminDown},	/* FSM_E_RecvDown      */
+    {
+    bfd_fsm_discard, FSM_S_AdminDown},	/* FSM_E_RecvInit      */
+    {
+    bfd_fsm_discard, FSM_S_AdminDown},	/* FSM_E_RecvUp        */
+    {
+    bfd_fsm_discard, FSM_S_AdminDown},	/* FSM_E_Timer         */
+    {
+    bfd_fsm_discard, FSM_S_AdminDown},	/* FSM_E_Delete        */
+  },
+    /* Down */
+  {
+    {
+    bfd_fsm_ignore, FSM_S_Down},	/* FSM_E_RecvAdminDown */
+    {
+    bfd_fsm_init, FSM_S_Init},	/* FSM_E_RecvDown      */
+    {
+    bfd_fsm_up, FSM_S_Up},	/* FSM_E_RecvInit      */
+    {
+    bfd_fsm_ignore, FSM_S_Down},	/* FSM_E_RecvUp        */
+    {
+    bfd_fsm_down, FSM_S_Down},	/* FSM_E_Timer         */
+    {
+    bfd_fsm_admdown, FSM_S_AdminDown},	/* FSM_E_Delete        */
+  },
+    /* Init */
+  {
+    {
+    bfd_fsm_admdown, FSM_S_Down},	/* FSM_E_RecvAdminDown */
+    {
+    bfd_fsm_init, FSM_S_Init},	/* FSM_E_RecvDown      */
+    {
+    bfd_fsm_up, FSM_S_Up},	/* FSM_E_RecvInit      */
+    {
+    bfd_fsm_up, FSM_S_Up},	/* FSM_E_RecvUp        */
+    {
+    bfd_fsm_down, FSM_S_Down},	/* FSM_E_Timer         */
+    {
+    bfd_fsm_admdown, FSM_S_AdminDown},	/* FSM_E_Delete        */
+  },
+    /* Up */
+  {
+    {
+    bfd_fsm_admdown, FSM_S_Down},	/* FSM_E_RecvAdminDown */
+    {
+    bfd_fsm_down, FSM_S_Down},	/* FSM_E_RecvDown      */
+    {
+    bfd_fsm_up, FSM_S_Up},	/* FSM_E_RecvInit      */
+    {
+    bfd_fsm_up, FSM_S_Up},	/* FSM_E_RecvUp        */
+    {
+    bfd_fsm_down, FSM_S_Down},	/* FSM_E_Timer         */
+    {
+    bfd_fsm_admdown, FSM_S_AdminDown},	/* FSM_E_Delete        */
+},};
+
+static const char *bfd_event_str[] = {
+  NULL,
+  "RecvAdminDown",
+  "RecvDown",
+  "RecvInit",
+  "RecvUp",
+  "Timer",
+  "Delete",
+};
+
+/* Event function, responsible for processing FSM events and
+   based on current FSM state run appropriate function */
+int
+bfd_event (struct bfd_neigh *neighp, int event)
+{
+  int ret = BFD_ERR;
+  int next = FSM[neighp->status - 1][event - 1].next_state;
+
+  if (BFD_IF_DEBUG_FSM && neighp->status != next)
+    BFD_FSM_LOG_DEBUG ("%s (%s->%s)", bfd_event_str[event],
+		       LOOKUP (bfd_status_msg, neighp->status),
+		       LOOKUP (bfd_status_msg, next))
+      if (FSM[neighp->status - 1][event - 1].func)
+      ret = (*(FSM[neighp->status - 1][event - 1].func)) (neighp);
+
+  if (ret == BFD_OK)
+    {
+      if (next != neighp->status)
+	{
+	  /* Remember the previous status */
+	  neighp->ostatus = neighp->status;
+	  neighp->status = next;
+	}
+    }
+  return ret;
+}
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_fsm.h quagga-0.99.9-bfd-0.90.1/bfdd/bfd_fsm.h
--- quagga-0.99.9/bfdd/bfd_fsm.h	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_fsm.h	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+ * BFDD - bfd_fsm.h
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef _QUAGGA_BFD_FSM_H
+#define _QUAGGA_BFD_FSM_H
+
+#define FSM_S_AdminDown	    1
+#define FSM_S_Down	    2
+#define FSM_S_Init	    3
+#define FSM_S_Up	    4
+#define FSM_S_MAX	    5
+
+#define FSM_E_RecvAdminDown 1
+#define FSM_E_RecvDown	    2
+#define FSM_E_RecvInit	    3
+#define FSM_E_RecvUp	    4
+#define FSM_E_Timer	    5
+#define FSM_E_Delete	    6
+#define FSM_E_MAX	    7
+
+int bfd_event (struct bfd_neigh *neighp, int event);
+int bfd_fsm_timer (struct thread *thread);
+int bfd_fsm_stimeout (struct thread *thread);
+int bfd_fsm_neigh_del (struct bfd_neigh *neighp);
+int bfd_fsm_neigh_add (struct bfd_neigh *neighp);
+
+#endif /* _QUAGGA_BFD_FSM_H */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_interface.c quagga-0.99.9-bfd-0.90.1/bfdd/bfd_interface.c
--- quagga-0.99.9/bfdd/bfd_interface.c	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_interface.c	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,214 @@
+/*
+ * BFDD - bfd_interface.c   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include <zebra.h>
+
+#include "log.h"
+#include "memory.h"
+#include "if.h"
+#include "linklist.h"
+#include "command.h"
+#include "thread.h"
+#include "hash.h"
+#include "prefix.h"
+#include "stream.h"
+#include "sockunion.h"
+
+#include "bfd.h"
+#include "bfdd/bfd_interface.h"
+#include "bfdd/bfdd.h"
+#include "bfdd/bfd_debug.h"
+
+/* rOUTINe responsible for creating a new bfd interface info
+   structure */
+struct bfd_if_info *
+bfd_if_info_new ()
+{
+  struct bfd_if_info *bii;
+  bii = XCALLOC (MTYPE_BFD_IF_INFO, sizeof (struct bfd_if_info));
+  if (bii)
+    {
+      /* bfd interface default settings */
+      bii->interval = BFD_IF_INTERVAL_DFT;
+      bii->minrx = BFD_IF_MINRX_DFT;
+      bii->multiplier = BFD_IF_MULTIPLIER_DFT;
+      bii->enabled = 1;
+      bii->passive = 0;
+    }
+  else
+    {
+      zlog_err ("Can't malloc bfd interface");
+      return NULL;
+    }
+
+  return bii;
+}
+
+/* Hooks for bfd interface information structure */
+static int
+bfd_if_new_hook (struct interface *ifp)
+{
+  ifp->info = bfd_if_info_new ();
+  return 0;
+}
+static int
+bfd_if_delete_hook (struct interface *ifp)
+{
+  XFREE (MTYPE_BFD_IF_INFO, ifp->info);
+  ifp->info = NULL;
+  return 0;
+}
+
+/* Initialize Zebra interface data structure. */
+void
+bfd_if_init ()
+{
+  if_init ();
+  bfd->iflist = iflist;
+  if_add_hook (IF_NEW_HOOK, bfd_if_new_hook);
+  if_add_hook (IF_DELETE_HOOK, bfd_if_delete_hook);
+}
+
+/* Check if interface is enabled */
+static int
+bfd_check_if_enabled (struct bfd_neigh *neighp)
+{
+  struct interface *ifp = if_lookup_by_index (neighp->ifindex);
+
+  if (!ifp)
+    if (!(ifp = if_lookup_by_sockunion_exact (neighp->su_local)))
+      abort ();
+  if (((struct bfd_if_info *) ifp->info)->enabled)
+    return BFD_OK;
+  else
+    return BFD_ERR;
+}
+
+/* Check if interface over which neighbor will run is passive.
+   In case interface is passive update neighbor's coresponding flag */
+void
+bfd_neigh_if_passive_update (struct bfd_neigh *neighp)
+{
+  struct bfd_if_info *bii = bfd_ifinfo_get (neighp);
+  if (bii->passive)
+    neighp->flags |= BFD_CNEIGH_FLAGS_PASSIVE;
+}
+
+/* Get bfd interface info structure for given neighbor */
+struct bfd_if_info *
+bfd_ifinfo_get (struct bfd_neigh *neighp)
+{
+  struct interface *ifp = if_lookup_by_index (neighp->ifindex);
+  if (!ifp)
+    if (!(ifp = if_lookup_by_sockunion_exact (neighp->su_local)))
+      abort ();
+  return (struct bfd_if_info *) ifp->info;
+}
+
+/* Check correctness of remote address i.e. if it is from
+   the same subnet as one of our interfaces */
+static int
+bfd_neigh_raddr_check (union sockunion *su)
+{
+  struct interface *ifp = NULL;
+
+  if ((ifp = if_lookup_prefix (sockunion2hostprefix (su))))
+    if (if_is_operative (ifp))
+      return BFD_OK;
+  return BFD_ERR;
+}
+
+/* Check correctness of local address - do we have such an address or not*/
+static int
+bfd_neigh_laddr_check (union sockunion *su)
+{
+  struct interface *ifp = NULL;
+
+  if (su->sa.sa_family == AF_INET)
+    ifp = if_lookup_exact_address (su->sin.sin_addr);
+#ifdef HAVE_IPV6
+  else if (su->sa.sa_family == AF_INET6)
+    ifp = if_lookup_exact_address6 (&su->sin6.sin6_addr);
+#endif /* HAVE IPV6 */
+
+  if (ifp)
+    if (if_is_operative (ifp))
+      return BFD_OK;
+  return BFD_ERR;
+}
+
+/* Function check if socket union addresses are correct
+   based on the mode in which neighbor is running i.e. 1HOP or MHOP*/
+static int
+bfd_neigh_addr_check (struct bfd_neigh *neighp)
+{
+  /* If neighbor is working in single hop mode 
+     check IP addresses on both sides of connection */
+  if (bfd_flag_1hop_check (neighp))
+    {
+      if (bfd_neigh_raddr_check (neighp->su_remote) < 0)
+	{
+	  if (BFD_IF_DEBUG_ZEBRA)
+	    BFD_LOG_DEBUG_NEIGH_ARG ("%s: remote address error(1hop)",
+				     __func__) return -1;
+	}
+      if (bfd_neigh_laddr_check (neighp->su_local) < 0)
+	{
+	  if (BFD_IF_DEBUG_ZEBRA)
+	    BFD_LOG_DEBUG_NEIGH_ARG ("%s: local address error(1hop)",
+				     __func__) return -2;
+	}
+    }
+  /* We have multihop neighbor - so let's check only local address */
+  else
+    {
+      if (bfd_neigh_laddr_check (neighp->su_local) < 0)
+	{
+	  if (BFD_IF_DEBUG_ZEBRA)
+	    BFD_LOG_DEBUG_NEIGH_ARG ("%s: local address error(mhop)",
+				     __func__) return -3;
+	}
+    }
+  return BFD_OK;
+}
+
+
+static int
+bfd_neigh_if_check (struct bfd_neigh *neighp)
+{
+  /* Check if bfd is enabled on desired interface */
+  if (bfd_check_if_enabled (neighp))
+    {
+      if (BFD_IF_DEBUG_ZEBRA)
+	BFD_LOG_DEBUG_NEIGH_ARG ("%s: bfd not enable on interface %s",
+				 __func__,
+				 ifindex2ifname (neighp->
+						 ifindex)) return BFD_ERR;
+    }
+  return BFD_OK;
+}
+
+
+int
+bfd_neigh_check (struct bfd_neigh *neighp)
+{
+  return (bfd_neigh_addr_check (neighp) | bfd_neigh_if_check (neighp));
+}
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_interface.h quagga-0.99.9-bfd-0.90.1/bfdd/bfd_interface.h
--- quagga-0.99.9/bfdd/bfd_interface.h	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_interface.h	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,57 @@
+/*
+ * BFDD - bfd_interface.h
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef _QUAGGA_BFD_INTERFACE_H
+#define _QUAGGA_BFD_INTERFACE_H
+
+#include "bfdd/bfdd.h"
+
+/* in msec */
+#define BFD_IF_INTERVAL_DFT	750
+#define BFD_IF_INTERVAL_MIN	200
+#define BFD_IF_INTERVAL_MAX	30000
+#define BFD_IF_MINRX_DFT	500
+#define BFD_IF_MINRX_MIN	200
+#define BFD_IF_MINRX_MAX	30000
+
+#define BFD_IF_MULTIPLIER_DFT	3
+#define BFD_IF_MULTIPLIER_MIN	1
+#define BFD_IF_MULTIPLIER_MAX	20
+
+struct bfd_if_info
+{
+  int enabled;			/* enabled flag */
+  int passive;			/* passive flag */
+  uint32_t interval;		/* desmintx */
+  uint32_t minrx;		/* reqminrx */
+  uint32_t multiplier;
+};
+
+
+void bfd_if_init (void);
+struct bfd_if_info *bfd_if_info_new (void);
+
+struct bfd_if_info *bfd_ifinfo_get (struct bfd_neigh *neighp);
+void bfd_neigh_if_passive_update (struct bfd_neigh *neighp);
+int bfd_neigh_check (struct bfd_neigh *neighp);
+
+
+#endif /* _QUAGGA_BFD_INTERFACE_H */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_main.c quagga-0.99.9-bfd-0.90.1/bfdd/bfd_main.c
--- quagga-0.99.9/bfdd/bfd_main.c	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_main.c	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,289 @@
+/*
+ * BFDD - bfd_main.c   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include <zebra.h>
+
+#include <lib/version.h>
+#include "getopt.h"
+#include "thread.h"
+#include "if.h"
+#include "log.h"
+#include "command.h"
+#include "memory.h"
+#include "sigevent.h"
+#include "privs.h"
+
+#include "bfdd/bfdd.h"
+#include "bfdd/bfd_zebra.h"
+#include "bfdd/bfd_interface.h"
+
+/* bfdd privileges */
+zebra_capabilities_t _caps_p[] = {
+  ZCAP_NET_RAW,
+  ZCAP_BIND,
+};
+
+struct zebra_privs_t bfdd_privs = {
+#if defined(QUAGGA_USER) && defined(QUAGGA_GROUP)
+  .user = QUAGGA_USER,
+  .group = QUAGGA_GROUP,
+#endif
+#if defined(VTY_GROUP)
+  .vty_group = VTY_GROUP,
+#endif
+  .caps_p = _caps_p,
+  .cap_num_p = sizeof (_caps_p) / sizeof (_caps_p[0]),
+  .cap_num_i = 0
+};
+
+/* Configuration filename and directory. */
+char config_default[] = SYSCONFDIR BFDD_DEFAULT_CONFIG;
+
+/* Manually specified configuration file name.  */
+char *config_file = NULL;
+
+/* Process ID saved for use by init system */
+const char *pid_file = PATH_BFDD_PID;
+
+/* Help information display. */
+static void
+usage (char *progname, int status)
+{
+  if (status != 0)
+    fprintf (stderr, "Try `%s --help' for more information.\n", progname);
+  else
+    {
+      printf ("Usage : %s [OPTION...]\n\
+BFD Deamon\n\n\
+-d, --daemon       Runs in daemon mode\n\
+-f, --config_file  Set configuration file name\n\
+-i, --pid_file     Set process identifier file name\n\
+-A, --vty_addr     Set vty's bind address\n\
+-P, --vty_port     Set vty's port number\n\
+-C, --dryrun       Check configuration for validity and exit\n\
+-u, --user         User to run as\n\
+-g, --group        Group to run as\n\
+-v, --version      Print program version\n\
+-h, --help         Display this help and exit\n\
+\n\
+Report bugs to %s\n", progname, ZEBRA_BUG_ADDRESS);
+    }
+
+  exit (status);
+}
+
+
+/* VTY port number and address.  */
+int vty_port = BFDD_VTY_PORT;
+char *vty_addr = NULL;
+
+
+/* BFDd Options */
+static struct option longopts[] = {
+  {"daemon", no_argument, NULL, 'd'},
+  {"config_file", required_argument, NULL, 'f'},
+  {"pid_file", required_argument, NULL, 'i'},
+  {"help", no_argument, NULL, 'h'},
+  {"dryrun", no_argument, NULL, 'C'},
+  {"vty_addr", required_argument, NULL, 'A'},
+  {"vty_port", required_argument, NULL, 'P'},
+  {"retain", no_argument, NULL, 'r'},
+  {"user", required_argument, NULL, 'u'},
+  {"group", required_argument, NULL, 'g'},
+  {"version", no_argument, NULL, 'v'},
+  {0}
+};
+
+/* Master of threads. */
+struct thread_master *master;
+
+/* SIGHUP handler. */
+static void
+sighup (void)
+{
+  zlog (NULL, LOG_INFO, "SIGHUP received");
+}
+
+/* SIGINT / SIGTERM handler. */
+static void
+sigint (void)
+{
+  zlog_notice ("Terminating on signal");
+  exit (0);
+}
+
+/* SIGUSR1 handler. */
+static void
+sigusr1 (void)
+{
+  zlog_rotate (NULL);
+}
+
+
+struct quagga_signal_t bfdd_signals[] = {
+  {
+   .signal = SIGHUP,
+   .handler = &sighup,
+   },
+  {
+   .signal = SIGUSR1,
+   .handler = &sigusr1,
+   },
+  {
+   .signal = SIGINT,
+   .handler = &sigint,
+   },
+  {
+   .signal = SIGTERM,
+   .handler = &sigint,
+   },
+};
+
+
+int
+main (int argc, char **argv, char **envp)
+{
+  char *p;
+  int daemon_mode = 0;
+  int dryrun = 0;
+  int vty_port = BFDD_VTY_PORT;
+  char *progname;
+  struct thread thread;
+
+  umask (0027);
+
+
+  progname = ((p = strrchr (argv[0], '/')) ? ++p : argv[0]);
+
+  zlog_default = openzlog (progname, ZLOG_BFD,
+			   LOG_CONS | LOG_NDELAY | LOG_PID, LOG_DAEMON);
+
+  /* Command line option parse. */
+  while (1)
+    {
+      int opt;
+
+      opt = getopt_long (argc, argv, "df:i:hA:P:u:g:vC", longopts, 0);
+
+      if (opt == EOF)
+	break;
+
+      switch (opt)
+	{
+	case 0:
+	  break;
+	case 'd':
+	  daemon_mode = 1;
+	  break;
+	case 'f':
+	  config_file = optarg;
+	  break;
+	case 'A':
+	  vty_addr = optarg;
+	  break;
+	case 'i':
+	  pid_file = optarg;
+	  break;
+	case 'P':
+	  /* Deal with atoi() returning 0 on failure, and bfdd not
+	     listening on bfd port... */
+	  if (strcmp (optarg, "0") == 0)
+	    {
+	      vty_port = 0;
+	      break;
+	    }
+	  vty_port = atoi (optarg);
+	  vty_port = (vty_port ? vty_port : BFDD_VTY_PORT);
+	  break;
+	case 'C':
+	  dryrun = 1;
+	  break;
+	case 'u':
+	  bfdd_privs.user = optarg;
+	  break;
+	case 'g':
+	  bfdd_privs.group = optarg;
+	  break;
+	case 'v':
+	  print_version (progname);
+	  exit (0);
+	  break;
+	case 'h':
+	  usage (progname, 0);
+	  break;
+	default:
+	  usage (progname, 1);
+	  break;
+	}
+    }
+
+
+  /* Prepare master thread. */
+  master = thread_master_create ();
+
+  /* Library initialization. */
+  zprivs_init (&bfdd_privs);
+  signal_init (master, Q_SIGC (bfdd_signals), bfdd_signals);
+  cmd_init (1);
+  vty_init (master);
+  memory_init ();
+
+  /* random seed from time */
+  srand (time (NULL));
+
+  /* BFD related initialization. */
+  bfd_init ();
+  bfd_if_init ();
+  bfd_zebra_init ();
+  bfd_vty_init ();
+
+  /* Sort all installed commands. */
+  sort_node ();
+
+  /* Get configuration file. */
+  vty_read_config (config_file, config_default);
+
+  //bfd_cfg();
+
+  /* Start execution only if not in dry-run mode */
+  if (dryrun)
+    return (0);
+
+  /* Change to the daemon program. */
+  if (daemon_mode)
+    daemon (0, 0);
+
+  /* Pid file create. */
+  pid_output (pid_file);
+
+  /* Create VTY's socket */
+  vty_serv_sock (vty_addr, vty_port, BFD_VTYSH_PATH);
+
+  /* Print banner. */
+  zlog_notice ("BFDd %s starting: vty@%d", QUAGGA_VERSION, vty_port);
+
+  /* Execute each thread. */
+  while (thread_fetch (master, &thread))
+    thread_call (&thread);
+
+  /* Not reached. */
+  return (0);
+}
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_net.c quagga-0.99.9-bfd-0.90.1/bfdd/bfd_net.c
--- quagga-0.99.9/bfdd/bfd_net.c	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_net.c	2007-10-21 17:02:52.000000000 +0200
@@ -0,0 +1,562 @@
+/*
+ * BFDD - bfd_net.c   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <zebra.h>
+
+#include "thread.h"
+#include "vty.h"
+#include "log.h"
+#include "if.h"
+#include "prefix.h"
+#include "privs.h"
+#include "sockopt.h"
+#include "sockunion.h"
+
+#include "bfd.h"
+#include "bfdd/bfdd.h"
+#include "bfdd/bfd_net.h"
+#include "bfdd/bfd_debug.h"
+#include "bfdd/bfd_packet.h"
+
+extern struct bfd_lport *bfd_lport;
+extern struct zebra_privs_t bfdd_privs;
+
+/* Get unique local port
+   "The source port MUST be in the range 49152 through 65535.  The same UDP
+   source port number MUST be used for all BFD Control packets
+   associated with a particular session.  The source port number SHOULD
+   be unique among all BFD sessions on the system.  If more than 16384
+   BFD sessions are simultaneously active, UDP source port numbers MAY
+   be reused on multiple sessions, but the number of distinct uses of
+   the same UDP source port number SHOULD be minimized." */
+
+static uint16_t
+bfd_getlport (struct bfd_neigh *neighp)
+{
+
+  uint16_t *port = NULL;
+  if (neighp->lport)
+    return neighp->lport;
+
+  switch (bfd_check_neigh_family (neighp))
+    {
+    case AF_INET:
+      port = &bfd_lport->v4;
+#ifdef HAVE_IPV6
+    case AF_INET6:
+      port = &bfd_lport->v6;
+#endif /* HAVE_IPV6 */
+    }
+
+  if ((*port >= (BFD_SOURCEPORT_MIN - 1)) && (*port < BFD_SOURCEPORT_MAX))
+    return ++(*port);
+  else
+    {
+      *port = BFD_SOURCEPORT_MIN;
+      return ++(*port);
+    }
+}
+
+/* Get remote port based on neighbor flags */
+static uint16_t
+bfd_getrport (struct bfd_neigh *neighp)
+{
+  if (bfd_flag_1hop_check (neighp))
+    {
+      if (bfd_flag_echo_check (neighp))
+	return BFD_PORT_1HOP_ECHO;
+      else
+	return BFD_PORT_1HOP;
+    }
+  else
+    return BFD_PORT_MHOP;
+}
+
+/* Create a UDP socket for a given family */
+static int
+bfd_sock (int family)
+{
+  int sock;
+  if ((sock = socket (family, SOCK_DGRAM, 0)) < 0)
+    {
+      zlog_err ("%s: cannot create family=%d socket: %s", __func__, family,
+		safe_strerror (errno));
+      abort ();
+    }
+  return sock;
+}
+
+/* Wrapping function for connect */
+static int
+bfd_connect (int sock, struct sockaddr *sa, socklen_t len)
+{
+  /*
+     if (bfdd_privs.change (ZPRIVS_RAISE))
+     zlog_err ("%s: cannot raise privs",__func__);
+   */
+  if (connect (sock, sa, len) < 0)
+    {
+      int save_errno = errno;
+      /*
+         if (bfdd_privs.change (ZPRIVS_LOWER))
+         zlog_err ("%s: cannot lower privs",__func__);
+       */
+      if (sa->sa_family == AF_INET)
+	zlog_err ("%s: cannot bind socket %d to %s port %d: %s", __func__,
+		  sock, inet_ntoa (((struct sockaddr_in *) sa)->sin_addr),
+		  (int) ntohs (((struct sockaddr_in *) sa)->sin_port),
+		  safe_strerror (save_errno));
+#ifdef HAVE_IPV6
+      else if (sa->sa_family == AF_INET6)
+	zlog_err ("%s: cannot bind socket %d to %s port %d: %s", __func__,
+		  sock, inet6_ntoa (((struct sockaddr_in6 *) sa)->sin6_addr),
+		  (int) ntohs (((struct sockaddr_in6 *) sa)->sin6_port),
+		  safe_strerror (save_errno));
+#endif /* HAVE_IPV6 */
+      else
+	abort ();
+
+      close (sock);
+      return -1;
+    }
+  /*
+     if (bfdd_privs.change (ZPRIVS_LOWER))
+     zlog_err ("%s: cannot lower privs", __func__);
+   */
+  return 0;
+}
+
+/* Wrapping function for bind */
+static int
+bfd_bind (int sock, struct sockaddr *sa, socklen_t len)
+{
+  if (bfdd_privs.change (ZPRIVS_RAISE))
+    zlog_err ("%s: cannot raise privs", __func__);
+
+  if (bind (sock, sa, len) < 0)
+    {
+      int save_errno = errno;
+      if (bfdd_privs.change (ZPRIVS_LOWER))
+	zlog_err ("%s: cannot lower privs", __func__);
+
+      if (sa->sa_family == AF_INET)
+	zlog_err ("%s: cannot bind socket %d to %s port %d: %s", __func__,
+		  sock, inet_ntoa (((struct sockaddr_in *) sa)->sin_addr),
+		  (int) ntohs (((struct sockaddr_in *) sa)->sin_port),
+		  safe_strerror (save_errno));
+#ifdef HAVE_IPV6
+      else if (sa->sa_family == AF_INET6)
+	zlog_err ("%s: cannot bind socket %d to %s port %d: %s", __func__,
+		  sock, inet6_ntoa (((struct sockaddr_in6 *) sa)->sin6_addr),
+		  (int) ntohs (((struct sockaddr_in6 *) sa)->sin6_port),
+		  safe_strerror (save_errno));
+#endif /* HAVE_IPV6 */
+      else
+	abort ();
+
+      close (sock);
+      return -1;
+    }
+  if (bfdd_privs.change (ZPRIVS_LOWER))
+    zlog_err ("%s: cannot lower privs", __func__);
+  return 0;
+}
+
+void
+bfd_sockclose (int sock)
+{
+  if (close (sock) < 0)
+    zlog_err ("%s: close error: %s", __func__, safe_strerror (errno));
+}
+
+/* Initialise socket for sending BFD packets */
+void
+bfd_sendsock_init (struct bfd_neigh *neighp)
+{
+  int ttl = 255;
+  int tos = 192;
+
+  switch (bfd_check_neigh_family (neighp))
+    {
+    case AF_INET:
+      {
+
+	struct sockaddr_in loc;
+	struct sockaddr_in rem;
+
+	memset (&loc, 0, sizeof (struct sockaddr_in));
+	memset (&rem, 0, sizeof (struct sockaddr_in));
+
+	neighp->sock = bfd_sock (AF_INET);
+
+	rem.sin_family = AF_INET;
+	rem.sin_addr.s_addr = sock2ip (neighp->su_remote);
+	rem.sin_port = htons (bfd_getrport (neighp));
+
+	loc.sin_family = AF_INET;
+	loc.sin_addr.s_addr = sock2ip (neighp->su_local);
+	loc.sin_port = htons (bfd_getlport (neighp));
+
+	setsockopt (neighp->sock, IPPROTO_IP, IP_TOS, &tos, sizeof (tos));
+	sockopt_ttl (AF_INET, neighp->sock, ttl);
+	sockopt_reuseaddr (neighp->sock);
+	sockopt_reuseport (neighp->sock);
+
+	bfd_bind (neighp->sock, (struct sockaddr *) &loc, sizeof (loc));
+	bfd_connect (neighp->sock, (struct sockaddr *) &rem, sizeof (rem));
+	break;
+      }
+#ifdef HAVE_IPV6
+    case AF_INET6:
+      {
+	struct sockaddr_in6 loc6;
+	struct sockaddr_in6 rem6;
+
+	memset (&loc6, 0, sizeof (struct sockaddr_in6));
+	memset (&rem6, 0, sizeof (struct sockaddr_in6));
+
+	neighp->sock = bfd_sock (AF_INET6);
+
+
+	rem6.sin6_family = AF_INET6;
+	memcpy (&rem6.sin6_addr, sock2ip6 (neighp->su_remote),
+		sizeof (struct in6_addr));
+	rem6.sin6_port = htons (bfd_getrport (neighp));
+
+	loc6.sin6_family = AF_INET6;
+	memcpy (&rem6.sin6_addr, sock2ip6 (neighp->su_remote),
+		sizeof (struct in6_addr));
+	loc6.sin6_port = htons (bfd_getlport (neighp));
+
+	//setsockopt(neighp->sock,IPPROTO_IP,IP_TOS, &tos, sizeof(tos));
+	sockopt_ttl (AF_INET6, neighp->sock, ttl);
+	sockopt_reuseaddr (neighp->sock);
+	sockopt_reuseport (neighp->sock);
+
+	bfd_bind (neighp->sock, (struct sockaddr *) &loc6, sizeof (loc6));
+	bfd_connect (neighp->sock, (struct sockaddr *) &rem6, sizeof (rem6));
+	break;
+      }
+#endif /* HAVE_IPV6 */
+    default:
+      abort ();
+    }
+
+  return;
+}
+
+/* Initialize server socket */
+int
+bfd_server_socket_init (int family, uint16_t port)
+{
+  int ret;
+  struct sockaddr_in addr;
+  struct sockaddr_in6 addr6;
+  int on = 1;
+  int sock = -1;
+
+  switch (family)
+    {
+    case AF_INET:
+      memset (&addr, 0, sizeof (struct sockaddr_in));
+      addr.sin_family = AF_INET;
+      addr.sin_addr.s_addr = INADDR_ANY;
+//#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
+//      addr.sin_len = sizeof (struct sockaddr_in);
+//#endif /* HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */
+      addr.sin_port = htons (port);
+      if ((sock = socket (AF_INET, SOCK_DGRAM, 0)) < 0)
+	{
+	  zlog_err ("bfd_socket_init: Cannot create UDP v4 socket: %s",
+		    safe_strerror (errno));
+	  exit (1);
+	}
+      if ((ret =
+	   setsockopt (sock, IPPROTO_IP, IP_PKTINFO, &on, sizeof (on))) < 0)
+	zlog_warn ("Can't set IP_PKTINFO option for fd %d to %d: %s", sock,
+		   on, safe_strerror (errno));
+      if ((ret =
+	   setsockopt (sock, IPPROTO_IP, IP_RECVTTL, &on, sizeof (on))) < 0)
+	zlog_warn ("Can't set IP_RECVTTL option for fd %d to %d: %s", sock,
+		   on, safe_strerror (errno));
+
+      sockopt_reuseaddr (sock);
+      sockopt_reuseport (sock);
+
+      if (bfdd_privs.change (ZPRIVS_RAISE))
+	zlog_err ("bfd_socket_init: could not raise privs");
+      if ((ret = bind (sock, (struct sockaddr *) &addr, sizeof (addr))) < 0)
+	{
+	  int save_errno = errno;
+	  if (bfdd_privs.change (ZPRIVS_LOWER))
+	    zlog_err ("bfd_socket_init: could not lower privs");
+	  zlog_err ("bfd_socket_init: Can't bind socket %d to %s port %d: %s",
+		    sock, inet_ntoa (addr.sin_addr),
+		    (int) ntohs (addr.sin_port), safe_strerror (save_errno));
+	  close (sock);
+	  return ret;
+	}
+      break;
+#ifdef HAVE_IPV6
+    case AF_INET6:
+      memset (&addr6, 0, sizeof (struct sockaddr_in6));
+      addr6.sin6_family = AF_INET6;
+      addr6.sin6_addr = in6addr_any;
+      addr6.sin6_port = htons (port);
+      if ((sock = socket (AF_INET6, SOCK_DGRAM, 0)) < 0)
+	{
+	  zlog_err ("bfd_socket_init: Cannot create UDP v6 socket: %s",
+		    safe_strerror (errno));
+	  exit (1);
+	}
+
+      /* FIXME: requires "linux/in6.h" but this might break portability, 
+         so no TTL check for v6 by default */
+      /*
+         if ((ret = setsockopt (sock, IPPROTO_IPV6, 
+         IPV6_RECVPKTINFO, &on, sizeof (on))) < 0)
+         zlog_warn ("Can't set IPV6_RECVPKTINFO option for fd %d to %d: %s",
+         sock,on,safe_strerror(errno));
+         if ((ret = setsockopt (sock, IPPROTO_IPV6, 
+         IPV6_RECVHOPLIMIT, &on, sizeof (on))) < 0)
+         zlog_warn ("Can't set IP_RECVTTL option for fd %d to %d: %s",
+         sock,on,safe_strerror(errno));
+       */
+#define IPV6_NOTTL_CHECK
+      setsockopt_ifindex (AF_INET6, sock, 1);
+      sockopt_reuseaddr (sock);
+      sockopt_reuseport (sock);
+
+      if (bfdd_privs.change (ZPRIVS_RAISE))
+	zlog_err ("bfd_socket_init: could not raise privs");
+      if ((ret = bind (sock, (struct sockaddr *) &addr6, sizeof (addr6))) < 0)
+	{
+	  int save_errno = errno;
+	  if (bfdd_privs.change (ZPRIVS_LOWER))
+	    zlog_err ("bfd_socket_init: could not lower privs");
+	  zlog_err ("bfd_socket_init: Can't bind socket %d to %s port %d: %s",
+		    sock, inet6_ntoa (addr6.sin6_addr),
+		    (int) ntohs (addr6.sin6_port),
+		    safe_strerror (save_errno));
+	  close (sock);
+	  return ret;
+	}
+      break;
+#endif
+    default:
+      zlog_err ("bfd_socket_init: family not supported");
+    }
+
+  if (bfdd_privs.change (ZPRIVS_LOWER))
+    zlog_err ("bfd_socket_init: could not lower privs");
+  return sock;
+}
+
+/* Receive IPv4 packet */
+static int
+bfd_recvmsg4 (int sock, u_char * buf, int size, struct sockaddr_in *from,
+	      struct in_addr *to, unsigned int *ifindex, u_char * ttl)
+{
+  int ret;
+  struct msghdr msg;
+  struct iovec iov;
+  struct cmsghdr *ptr;
+  char adata[1024];
+
+  msg.msg_name = (void *) from;
+  msg.msg_namelen = sizeof (struct sockaddr_in);
+  msg.msg_iov = &iov;
+  msg.msg_iovlen = 1;
+  msg.msg_control = (void *) adata;
+  msg.msg_controllen = sizeof adata;
+  iov.iov_base = buf;
+  iov.iov_len = size;
+
+  ret = recvmsg (sock, &msg, 0);
+  if (ret < 0)
+    return ret;
+
+  for (ptr = ZCMSG_FIRSTHDR (&msg); ptr != NULL;
+       ptr = CMSG_NXTHDR (&msg, ptr))
+    {
+      if (ptr->cmsg_level == IPPROTO_IP && ptr->cmsg_type == IP_PKTINFO)
+	{
+	  struct in_pktinfo *pktinfo;
+	  pktinfo = (struct in_pktinfo *) CMSG_DATA (ptr);
+	  *ifindex = (unsigned int) pktinfo->ipi_ifindex;
+	  to->s_addr = ((struct in_addr *) &pktinfo->ipi_spec_dst)->s_addr;
+	}
+      if (ptr->cmsg_level == IPPROTO_IP && ptr->cmsg_type == IP_TTL)
+	*ttl = (*(u_char *) CMSG_DATA (ptr));
+    }
+  return ret;
+}
+
+#ifdef HAVE_IPV6
+/* Receive IPv6 packet */
+static int
+bfd_recvmsg6 (int sock, u_char * buf, int size, struct sockaddr_in6 *from,
+	      struct in6_addr *to, unsigned int *ifindex, u_char * ttl)
+{
+  int ret;
+  struct msghdr msg;
+  struct iovec iov;
+  struct cmsghdr *ptr;
+  char adata[1024];
+
+  msg.msg_name = (void *) from;
+  msg.msg_namelen = sizeof (struct sockaddr_in6);
+  msg.msg_iov = &iov;
+  msg.msg_iovlen = 1;
+  msg.msg_control = (void *) adata;
+  msg.msg_controllen = sizeof adata;
+  iov.iov_base = buf;
+  iov.iov_len = size;
+
+  ret = recvmsg (sock, &msg, 0);
+  if (ret < 0)
+    return ret;
+
+  for (ptr = ZCMSG_FIRSTHDR (&msg); ptr != NULL;
+       ptr = CMSG_NXTHDR (&msg, ptr))
+    if (ptr->cmsg_level == IPPROTO_IPV6 && ptr->cmsg_type == IPV6_PKTINFO)
+      {
+	struct in6_pktinfo *pktinfo;
+	pktinfo = (struct in6_pktinfo *) CMSG_DATA (ptr);
+	*ifindex = (unsigned int) pktinfo->ipi6_ifindex;
+	memcpy (to, &pktinfo->ipi6_addr, sizeof (pktinfo->ipi6_addr));
+/*
+    if(ptr->cmsg_level == IPPROTO_IPV6 && ptr->cmsg_type == IPV6_HOPLIMIT)
+      *ttl = (*(u_char*) CMSG_DATA(ptr));
+*/
+      }
+  return ret;
+}
+#endif
+
+static int
+bfd_read4 (int sock, uint16_t port)
+{
+
+  union bfd_buf bfd_buf;
+  struct bfd_packet *bp;
+  unsigned int ifindex;
+  u_char ttl;
+  socklen_t fromlen;
+  struct sockaddr_in from;
+  struct in_addr to;
+  int len;
+  union sockunion rem, loc;
+
+  memset (&to, 0, sizeof (struct in_addr));
+  memset (&from, 0, sizeof (struct sockaddr_in));
+  fromlen = sizeof (struct sockaddr_in);
+
+  len =
+    bfd_recvmsg4 (sock, (u_char *) & bfd_buf.buf, sizeof (bfd_buf.buf), &from,
+		  &to, &ifindex, &ttl);
+
+  bp = &bfd_buf.bfd_packet;
+
+  loc.sin.sin_family = AF_INET;
+  loc.sin.sin_port = htons (port);
+  loc.sin.sin_addr.s_addr = to.s_addr;
+  rem.sin.sin_family = AF_INET;
+  rem.sin.sin_port = from.sin_port;
+  rem.sin.sin_addr.s_addr = from.sin_addr.s_addr;
+
+  return bfd_pkt_recv (&loc, &rem, bp, ifindex, ttl, len);
+}
+
+#ifdef HAVE_IPV6
+static int
+bfd_read6 (int sock, uint16_t port)
+{
+  union bfd_buf bfd_buf;
+  struct bfd_packet *bp;
+  unsigned int ifindex;
+  u_char ttl;
+  socklen_t fromlen;
+  struct sockaddr_in6 from;
+  struct in6_addr to;
+  int len;
+  union sockunion rem, loc;
+
+  memset (&to, 0, sizeof (struct in6_addr));
+  memset (&from, 0, sizeof (struct sockaddr_in6));
+  fromlen = sizeof (struct sockaddr_in6);
+
+  len =
+    bfd_recvmsg6 (sock, (u_char *) & bfd_buf.buf, sizeof (bfd_buf.buf), &from,
+		  &to, &ifindex, &ttl);
+
+  bp = &bfd_buf.bfd_packet;
+
+  loc.sin6.sin6_family = AF_INET6;
+  loc.sin6.sin6_port = htons (port);
+  memcpy (&loc.sin6.sin6_addr, &to, sizeof (struct in6_addr));
+  rem.sin6.sin6_family = AF_INET6;
+  rem.sin6.sin6_port = from.sin6_port;
+  memcpy (&rem.sin6.sin6_addr, &from.sin6_addr, sizeof (struct in6_addr));
+
+  return bfd_pkt_recv (&loc, &rem, bp, ifindex, ttl, len);
+}
+#endif /* HAVE_IPV6 */
+
+/* Read threads - responsible for serving server sockets */
+int
+bfd_read4_1hop (struct thread *t)
+{
+  int ret = bfd_read4 (THREAD_FD (t), BFD_PORT_1HOP);
+  bfd->t_read4_1hop = NULL;
+  BFD_READ_ON (bfd->t_read4_1hop, bfd_read4_1hop, bfd->sock4_1hop);
+  return ret;
+}
+
+#ifdef HAVE_IPV6
+int
+bfd_read6_1hop (struct thread *t)
+{
+  int ret = bfd_read6 (THREAD_FD (t), BFD_PORT_1HOP);
+  bfd->t_read6_1hop = NULL;
+  BFD_READ_ON (bfd->t_read6_1hop, bfd_read6_1hop, bfd->sock6_1hop);
+  return ret;
+}
+#endif /* HAVE_IPV6 */
+
+int
+bfd_read4_mhop (struct thread *t)
+{
+  int ret = bfd_read4 (THREAD_FD (t), BFD_PORT_MHOP);
+  bfd->t_read4_1hop = NULL;
+  BFD_READ_ON (bfd->t_read4_mhop, bfd_read4_mhop, bfd->sock4_mhop);
+  return ret;
+}
+
+#ifdef HAVE_IPV6
+int
+bfd_read6_mhop (struct thread *t)
+{
+  int ret = bfd_read6 (THREAD_FD (t), BFD_PORT_MHOP);
+  bfd->t_read6_mhop = NULL;
+  BFD_READ_ON (bfd->t_read6_mhop, bfd_read6_mhop, bfd->sock6_mhop);
+  return ret;
+}
+#endif /* HAVE_IPV6 */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_net.h quagga-0.99.9-bfd-0.90.1/bfdd/bfd_net.h
--- quagga-0.99.9/bfdd/bfd_net.h	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_net.h	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ * BFDD - bfd_net.h   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef _QUAGGA_BFD_NET_H
+#define _QUAGGA_BFD_NET_H
+
+int bfd_server_socket_init (int family, uint16_t port);
+void bfd_sendsock_init (struct bfd_neigh *neighp);
+void bfd_sockclose (int sock);
+
+int bfd_read4_1hop (struct thread *t);
+int bfd_read4_mhop (struct thread *t);
+#ifdef HAVE_IPV6
+int bfd_read6_1hop (struct thread *t);
+int bfd_read6_mhop (struct thread *t);
+#endif /* HAVE_IPV6 */
+
+#endif /* _QUAGGA_BFD_NET_H */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_packet.c quagga-0.99.9-bfd-0.90.1/bfdd/bfd_packet.c
--- quagga-0.99.9/bfdd/bfd_packet.c	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_packet.c	2007-10-21 01:34:47.000000000 +0200
@@ -0,0 +1,441 @@
+/*
+ * BFDD - bfd_packet.c   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+    
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <zebra.h>
+
+#include "thread.h"
+#include "vty.h"
+#include "log.h"
+#include "if.h"
+#include "prefix.h"
+#include "table.h"
+#include "privs.h"
+#include "sockunion.h"
+
+#include "bfd.h"
+#include "bfdd/bfdd.h"
+#include "bfdd/bfd_fsm.h"
+#include "bfdd/bfd_debug.h"
+#include "bfdd/bfd_zebra.h"
+#include "bfdd/bfd_interface.h"
+#include "bfdd/bfd_packet.h"
+
+
+int
+bfd_pkt_recv (union sockunion *loc, union sockunion *rem,
+	      struct bfd_packet *bp, unsigned int ifindex, int ttl, int len)
+{
+
+  struct bfd_neigh key, *neighp;
+  struct interface *ifp;
+  uint16_t lport;
+  uint16_t rport;
+  int ret = BFD_ERR;
+
+  if (len < 0)
+    {
+      zlog_info ("bfd_recvmsg failed: %s", safe_strerror (errno));
+      return len;
+    }
+
+  lport = ntohs (loc->sin.sin_port);
+  rport = ntohs (rem->sin.sin_port);
+
+  if (BFD_IF_DEBUG_NET)
+    {
+      zlog_debug ("RECV packet from %s:%u to %s:%u on %s",
+		  sockunion_su2str (rem), rport,
+		  sockunion_su2str (loc), lport, ifindex2ifname (ifindex));
+    }
+  /* If we operate in "Signle Hop" mode:
+     "All received BFD Control packets that are demultiplexed to the
+     session MUST be discarded if the received TTL or Hop Count is not
+     equal to 255." */
+#define IPV6_NOTTL_CHECK
+#ifndef IPV6_NOTTL_CHECK
+  if ((lport == BFD_PORT_1HOP) && (ttl < 255))
+    {
+      if (BFD_IF_DEBUG_NET)
+	zlog_debug ("%s: wrong ttl value for 1-hop session (ttl<255).",
+		    __func__);
+      return BFD_ERR;
+    }
+#else
+  if ((sockunion_family (loc) == AF_INET) &&
+      (lport == BFD_PORT_1HOP) && (ttl < 255))
+    {
+      if (BFD_IF_DEBUG_NET)
+	zlog_debug ("%s: wrong ttl value for 1-hop session (ttl<255).",
+		    __func__);
+      return BFD_ERR;
+    }
+#endif
+
+  /* "The source port MUST be in the range 49152 through 65535." */
+#ifdef STRICT_NEIGHBOR_CHECK
+  if (rport < BFD_SOURCEPORT_MIN)
+    {
+      if (BFD_IF_DEBUG_NET)
+	zlog_debug ("%s: source port not within allowed range.", __func__);
+      return BFD_ERR;
+    }
+#endif
+
+  /* Check if incoming interface is known */
+  ifp = if_lookup_by_index (ifindex);
+  if (ifp == NULL)
+    {
+      if (BFD_IF_DEBUG_NET)
+	zlog_debug ("%s: cannot find interface for packet from %s port %d",
+		    __func__, sockunion_su2str (rem), rport);
+      return -1;
+    }
+  /* "If the version number is not correct (1), 
+     the packet MUST be discarded." */
+  if (bp->vers != 1)
+    {
+      if (BFD_IF_DEBUG_NET)
+	zlog_debug ("%s: wrong packet version (%d!=1).", __func__, bp->vers);
+      return BFD_ERR;
+    }
+
+  /* "If the Length field is less than the minimum correct value (24 if
+     the A bit is clear, or 26 if the A bit is set), the packet MUST be
+     discarded." */
+  if (((bp->length < BFD_PACKET_SIZE_NOAUTH) && (bp->a == 0))
+      || ((bp->length < BFD_PACKET_SIZE_AUTH) && (bp->a == 1)))
+    {
+      if (BFD_IF_DEBUG_NET)
+	zlog_debug ("%s: too short packet (length=%d,A=%d).", __func__,
+		    bp->length, bp->a);
+      return BFD_ERR;
+    }
+
+  /* "If the Length field is greater than the payload of the
+     encapsulating protocol, the packet MUST be discarded." */
+  if (bp->length > len)
+    {
+      if (BFD_IF_DEBUG_NET)
+	zlog_debug
+	  ("%s: length value from packet suggest that packet is longer "
+	   "than payload of the encapsulating protocol "
+	   "(packet length=%d, payload length=%d).",
+	   __func__, bp->length, len);
+      return BFD_ERR;
+    }
+
+  /* "If the Detect Mult field is zero, the packet MUST be discarded." */
+  if (bp->multiplier == 0)
+    {
+      if (BFD_IF_DEBUG_NET)
+	zlog_debug ("%s: illegal Detection Multiplier (equal to zero).",
+		    __func__);
+      return BFD_ERR;
+    }
+
+  /* "If the Multipoint (M) bit is nonzero, the packet MUST be discarded." */
+  if (bp->m)
+    {
+      if (BFD_IF_DEBUG_NET)
+	zlog_debug ("%s: Non-zero value of M-bit detected.", __func__);
+      return BFD_ERR;
+    }
+
+  /* "A BFD Control packet MUST NOT have both 
+     the Poll (P) and Final (F) bits set." */
+#ifdef STRICT_NEIGHBOR_CHECK
+  if ((bp->p) && (bp->f))
+    {
+      if (BFD_IF_DEBUG_NET)
+	zlog_debug ("%s: P and F-bit set together are not allowed.",
+		    __func__);
+      return BFD_ERR;
+    }
+#endif
+
+  /* "If the My Discriminator field is zero, the packet MUST be discarded." */
+  if (bp->mydisc == 0)
+    {
+      if (BFD_IF_DEBUG_NET)
+	zlog_debug ("%s: illegal My Discriminator (equal to zero).",
+		    __func__);
+      return BFD_ERR;
+    }
+
+  /* "If the Your Discriminator field is zero and the State field is not
+     Down or AdminDown, the packet MUST be discarded." */
+  if ((bp->yourdisc == 0)
+      && (!(bp->sta == BFD_STATE_DOWN || bp->sta == BFD_STATE_ADMINDOWN)))
+    {
+      if (BFD_IF_DEBUG_NET)
+	zlog_debug
+	  ("%s: Your discriminator field is equal to zero "
+	   "while state is not Down or AdminDown.", __func__);
+      return BFD_ERR;
+    }
+
+  /* "If the Your Discriminator field is nonzero, it MUST be used to select 
+     the session with which this BFD packet is associated.  
+     If no session is found, the packet MUST be discarded." */
+  if (bp->yourdisc != 0)
+    {
+      key.ldisc = ntohl (bp->yourdisc);
+      if (!
+	  (neighp = (struct bfd_neigh *) hash_lookup (neightbl->ldisc, &key)))
+	{
+	  if (BFD_IF_DEBUG_NET)
+	    zlog_debug ("%s: No session exists (0x%08x/%d).", __func__,
+			key.ldisc, key.ldisc);
+	  return BFD_ERR;
+	}
+    }
+  /* "If the Your Discriminator field is zero, the session MUST be
+     selected based on some combination of other fields, possibly
+     including source addressing information, the My Discriminator
+     field, and the interface over which the packet was received.  The
+     exact method of selection is application-specific and is thus
+     outside the scope of this specification.  If a matching session is
+     not found, a new session may be created, or the packet may be
+     discarded.  This choice is outside the scope of this
+     specification. */
+  else
+    {
+      struct prefix *lp = sockunion2hostprefix (loc);
+      struct prefix *rp = sockunion2hostprefix (rem);
+
+      if (!(neighp = bfd_find_neigh (rp, lp, ifindex)))
+	{
+	  if (BFD_IF_DEBUG_NET)
+	    zlog_debug
+	      ("%s: Unable to demultiplex session src=%s:%d/dst=%s:%d on intf=%s.",
+	       __func__, sockunion_su2str (rem), ntohs (rem->sin.sin_port),
+	       sockunion_su2str (loc), ntohs (loc->sin.sin_port),
+	       ifindex2ifname (ifindex));
+	  return BFD_ERR;
+	}
+      prefix_free (lp);
+      prefix_free (rp);
+    }
+
+  if (bp->length > BFD_PACKET_SIZE_NOAUTH)
+    {
+      /* If the A bit is set and no authentication is in use (bfd.AuthType
+         is zero), the packet MUST be discarded." */
+      if ((bp->a == 1) && (bp->authtype == 0))
+	{
+	  if (BFD_IF_DEBUG_NET)
+	    zlog_debug ("%s: A-bit set but no authentication in use.",
+			__func__);
+	  return BFD_ERR;
+	}
+
+      /* "If the A bit is clear and authentication is in use (bfd.AuthType
+         is nonzero), the packet MUST be discarded." */
+      if ((bp->a == 0) && (bp->authtype != 0))
+	{
+	  if (BFD_IF_DEBUG_NET)
+	    zlog_debug ("%s: A-bit clear but authentication in use.",
+			__func__);
+	  return BFD_ERR;
+	}
+    }
+
+  /* Collect remote's neighbor flags, but first clear local storage  */
+  neighp->rbits = 0;
+
+  /* "Set bfd.RemoteDemandMode to the value of the Demand (D) bit." */
+  if (bp->d)
+    neighp->rbits |= BFD_BIT_D;
+  if (bp->a)
+    neighp->rbits |= BFD_BIT_A;
+  if (bp->c)
+    neighp->rbits |= BFD_BIT_C;
+  if (bp->p)
+    neighp->rbits |= BFD_BIT_P;
+  else if (bp->f)
+    neighp->rbits |= BFD_BIT_F;
+
+
+  /* "If the A bit is set, the packet MUST be authenticated under the
+     rules of section 6.7, based on the authentication type in use
+     (bfd.AuthType.)  This may cause the packet to be discarded." */
+  if (bp->a)
+    ;				/* TODO */
+
+  /* "Set bfd.RemoteDiscr to the value of My Discriminator." */
+  neighp->rdisc = ntohl (bp->mydisc);
+
+  /* "Set bfd.RemoteState to the value of the State (Sta) field." */
+  neighp->rstate = bp->sta;
+
+  /* "Set bfd.RemoteMinRxInterval to the value of Required Min RX
+     Interval." */
+  neighp->rreqminrx = ntohl (bp->reqminrx);
+
+  /* Grab some additional data from neighbor */
+  neighp->rdesmintx = ntohl (bp->desmintx);
+  neighp->rreqminechorx = ntohl (bp->reqminechorx);
+  neighp->rmulti = bp->multiplier;
+  neighp->rdiag = bp->diag;
+  neighp->rlen = bp->length;
+  neighp->rver = bp->vers;
+
+  /* "If the Required Min Echo RX Interval field is zero, the
+     transmission of Echo packets, if any, MUST cease." */
+  if (neighp->rreqminechorx == 0)
+    {
+      /* TODO */
+    }
+
+  /* "If a Poll Sequence is being transmitted by the local system and
+     the Final (F) bit in the received packet is set, the Poll Sequence
+     MUST be terminated." */
+  if (bp->f)
+    neighp->lbits &= ~BFD_BIT_P;
+  else if (bp->p)
+    neighp->lbits |= BFD_BIT_F;
+
+  /* If a valid packet has been received from remote system
+     and local system is passive (i.e. configured as passive 
+     and without running t_hello thread) - start periodic
+     transmission of contol packets.                       */
+  if (bfd_flag_passive_check (neighp) && !neighp->t_hello)
+    BFD_TIMER_MSEC_ON (neighp->t_hello, bfd_pkt_xmit,
+		       MSEC (BFD_LDESMINTX_DFT));
+
+  /* Recveive interval negotiation  for "Detection Time" */
+  neighp->negrxint =
+    neighp->lreqminrx >
+    neighp->rdesmintx ? neighp->lreqminrx : neighp->rdesmintx;
+
+  /* Calculating the Detection time */
+  neighp->dtime = neighp->rmulti * neighp->negrxint;
+
+  /* Enter FSM */
+  switch (bp->sta)
+    {
+    case BFD_STATE_ADMINDOWN:
+      ret = bfd_event (neighp, FSM_E_RecvAdminDown);
+      break;
+    case BFD_STATE_DOWN:
+      ret = bfd_event (neighp, FSM_E_RecvDown);
+      break;
+    case BFD_STATE_INIT:
+      ret = bfd_event (neighp, FSM_E_RecvInit);
+      break;
+    case BFD_STATE_UP:
+      ret = bfd_event (neighp, FSM_E_RecvUp);
+      break;
+    }
+
+  if (ret == BFD_OK)
+    {
+      /* "If the packet was not discarded, it has been received for purposes
+         of the Detection Time expiration" */
+      BFD_TIMER_OFF (neighp->t_timer);
+
+      /* If remote system do not operate in demand mode 
+         and session is not being deleted start the timer thread */
+      if (!bfd_neigh_check_rbit_d (neighp) && !neighp->del)
+	BFD_TIMER_MSEC_ON (neighp->t_timer, bfd_fsm_timer,
+			   MSEC (neighp->dtime));
+
+      /* Update statistics only if delete flag is not set */
+      if (!neighp->del)
+	{
+	  neighp->last_recv = time (NULL);
+	  neighp->recv_cnt++;
+	}
+    }
+
+  return ret;
+}
+
+static int
+bfd_hello_send (struct bfd_neigh *neighp)
+{
+  struct bfd_packet packet;
+
+  memset (&packet, 0, sizeof (struct bfd_packet));
+
+  /* Build a packet */
+  packet.vers = BFD_PROTOCOL_VERSION;
+  packet.diag = neighp->ldiag;
+  packet.sta = neighp->lstate;
+  packet.p = bfd_neigh_check_lbit_p (neighp);
+  packet.f = bfd_neigh_check_lbit_f (neighp);
+  packet.c = bfd_neigh_check_lbit_c (neighp);
+  packet.a = bfd_neigh_check_lbit_a (neighp);
+  packet.d = bfd_neigh_check_lbit_d (neighp);
+  packet.m = bfd_neigh_check_lbit_m (neighp);
+  packet.multiplier = neighp->lmulti;
+  packet.length = bfd_neigh_check_lplen (neighp);
+  packet.mydisc = htonl (neighp->ldisc);
+  packet.yourdisc = htonl (neighp->rdisc);
+  packet.desmintx = htonl (neighp->ldesmintx_a);
+  packet.reqminrx = htonl (neighp->lreqminrx_a);
+  packet.reqminechorx = htonl (neighp->lreqminechorx);
+
+
+/* TODO
+  packet.authtype = ;
+  packet.authlen  = ;
+  packet,authdata = ;
+*/
+
+  /* FIXME: we are not interested is processing 
+     errros from udp connected socket */
+  return write (neighp->sock, &packet, packet.length);
+}
+
+/* Function is responsible for periodic BFD CPs transmission */
+int
+bfd_pkt_xmit (struct thread *thread)
+{
+  int ret;
+  struct bfd_neigh *neighp = THREAD_ARG (thread);
+
+  neighp->t_hello = NULL;
+
+  /* Transmit interval negotiation */
+  neighp->negtxint =
+    neighp->rreqminrx >
+    neighp->ldesmintx ? neighp->rreqminrx : neighp->ldesmintx;
+
+  /* Jittering xmit intervals */
+  if (neighp->rmulti == 1)
+    neighp->txint = bfd_jtimer_mult_is1 (neighp->negtxint);
+  else
+    neighp->txint = bfd_jtimer_mult_isnot1 (neighp->negtxint);
+
+  /* Reschedule myself */
+  BFD_TIMER_MSEC_ON (neighp->t_hello, bfd_pkt_xmit, BFD_TXINT (neighp));
+
+  ret = bfd_hello_send (neighp);
+
+  if (bfd_neigh_check_lbit_f (neighp))
+    neighp->lbits &= ~BFD_BIT_F;
+
+  /* Statistics */
+  neighp->last_xmit = time (NULL);
+  neighp->xmit_cnt++;
+
+  return ret;
+}
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_packet.h quagga-0.99.9-bfd-0.90.1/bfdd/bfd_packet.h
--- quagga-0.99.9/bfdd/bfd_packet.h	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_packet.h	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,183 @@
+/*
+ * BFDD - bfd_packet.h   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+    
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef _QUAGGA_BFD_PACKET_H
+#define _QUAGGA_BFD_PACKET_H
+
+/*
+   Diagnostic (Diag)
+
+  0 -- No Diagnostic
+  1 -- Control Detection Time Expired
+  2 -- Echo Function Failed
+  3 -- Neighbor Signaled Session Down
+  4 -- Forwarding Plane Reset
+  5 -- Path Down
+  6 -- Concatenated Path Down
+  7 -- Administratively Down
+  8 -- Reverse Concatenated Path Down
+  9-31 -- Reserved for future use
+
+*/
+
+#define BFD_DIAG_NODIAG            0
+#define BFD_DIAG_TIMEEXPIRED       1
+#define BFD_DIAG_ECHOFAILED        2
+#define BFD_DIAG_SESSIONDOWN       3
+#define BFD_DIAG_FWDRESET          4
+#define BFD_DIAG_PATHDOWN          5
+#define BFD_DIAG_CONCATPATHDOWN    6
+#define BFD_DIAG_ADMINDOWN         7
+#define BFD_DIAG_REVCONCATPATHDOWN 8
+
+#define BFD_PROTOCOL_VERSION       1
+
+#define BFD_STATE_ADMINDOWN        0
+#define BFD_STATE_DOWN             1
+#define BFD_STATE_INIT             2
+#define BFD_STATE_UP               3
+
+#define BFD_DFT_MULTI              3
+
+#define BFD_PACKET_SIZE_NOAUTH     24
+#define BFD_PACKET_SIZE_AUTH       26
+#define BFD_PACKET_SIZE_MAX BFD_PACKET_SIZE_AUTH
+
+/*
+                Generic BFD Control Packet Format
+
+   0                   1                   2                   3
+   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |Vers |  Diag   |Sta|P|F|C|A|D|M|  Detect Mult  |    Length     |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                       My Discriminator                        |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                      Your Discriminator                       |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                    Desired Min TX Interval                    |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                   Required Min RX Interval                    |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                 Required Min Echo RX Interval                 |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+ An optional Authentication Section may be present:
+
+   0                   1                   2                   3
+   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |   Auth Type   |   Auth Len    |    Authentication Data...     |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+*/
+
+struct bfd_packet
+{
+#if (BYTE_ORDER == LITTLE_ENDIAN)
+  uint8_t diag:5;
+  uint8_t vers:3;
+
+  uint8_t m:1;
+  uint8_t d:1;
+  uint8_t a:1;
+  uint8_t c:1;
+  uint8_t f:1;
+  uint8_t p:1;
+  uint8_t sta:2;
+#elif (BYTE_ORDER == BIG_ENDIAN)
+  uint8_t vers:3;
+  uint8_t diag:5;
+
+  uint8_t sta:2;
+  uint8_t p:1;
+  uint8_t f:1;
+  uint8_t c:1;
+  uint8_t a:1;
+  uint8_t d:1;
+  uint8_t m:1;
+#endif
+  uint8_t multiplier;
+  uint8_t length;
+  uint32_t mydisc;
+  uint32_t yourdisc;
+
+#define BFD_RREQMINRX_DFT       1
+#define BFD_LDESMINTX_DFT       1000000
+  uint32_t desmintx;
+
+#define BFD_LREQMINRX_DFT       250000
+  uint32_t reqminrx;
+#define BFD_REQMINECHORX_DFT 0
+  uint32_t reqminechorx;
+
+#define BFD_AUTH_NOAUTH         0
+#define BFD_AUTH_SIMPLE         1
+#define BFD_AUTH_KEYMD5         2
+#define BFD_AUTH_MKEYMD5        3
+#define BFD_AUTH_KEYSHA1        4
+#define BFD_AUTH_MKEYSHA1       5
+  uint8_t authtype;
+  uint8_t authlen;
+  uint16_t authdata;
+};
+
+union bfd_buf
+{
+  struct bfd_packet bfd_packet;
+  char buf[BFD_PACKET_SIZE_MAX];
+};
+
+/* unit conversion */
+#define MSEC(T) ((T)/1000)	/* USEC->MSEC */
+#define USEC(T) ((T)*1000)	/* MSEC->USEC */
+
+#define BFD_TXINT(NEIGHP) (((NEIGHP)->txint)/1000)
+#define BFD_DTIME(NEIGHP) (((NEIGHP)->dtime)/1000)
+
+/* Jitter
+   "The periodic transmission of BFD Control packets SHOULD be jittered
+   by up to 25%, that is, the interval SHOULD be reduced by a random
+   value of 0 to 25%, in order to avoid self-synchronization.  Thus, the
+   average interval between packets may be up to 12.5% less than that
+   negotiated.
+
+   If bfd.DetectMult is equal to 1, the interval between transmitted BFD
+   Control packets MUST be no more than 90% of the negotiated
+   transmission interval, and MUST be no less than 75% of the negotiated
+   transmission interval.  This is to ensure that, on the remote system,
+   the calculated DetectTime does not pass prior to the receipt of the
+   next BFD Control packet." */
+
+/* Generates a percentage (p) jitter from the given timer (t) */
+#define bfd_timer_jitter(t,p) \
+        (1 + (uint32_t) (((t)*(p)) * (rand() / (RAND_MAX + 1.0))))
+/* Generates a value in range 75% - 100% of t */
+#define bfd_jtimer_mult_isnot1(t) ((t) - bfd_timer_jitter((t),0.25))
+/* Generates a random value in range ~75% - 90% of t */
+#define bfd_jtimer_mult_is1(t) \
+       ((uint32_t)((double)((t)*0.90)) - bfd_timer_jitter(((t)*0.90),0.16))
+
+
+int bfd_pkt_recv (union sockunion *loc, union sockunion *rem,
+		  struct bfd_packet *bp, unsigned int ifindex, int ttl,
+		  int len);
+int bfd_pkt_xmit (struct thread *thread);
+
+#endif /* _QUAGGA_BFD_PACKET_H */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_zebra.c quagga-0.99.9-bfd-0.90.1/bfdd/bfd_zebra.c
--- quagga-0.99.9/bfdd/bfd_zebra.c	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_zebra.c	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,604 @@
+/*
+ * BFDD - bfd_zebra.c   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include <zebra.h>
+
+#include "command.h"
+#include "stream.h"
+#include "network.h"
+#include "prefix.h"
+#include "log.h"
+#include "sockunion.h"
+#include "zclient.h"
+#include "routemap.h"
+#include "thread.h"
+#include "hash.h"
+#include "table.h"
+
+#include "bfd.h"
+#include "bfdd/bfdd.h"
+#include "bfdd/bfd_zebra.h"
+#include "bfdd/bfd_debug.h"
+#include "bfdd/bfd_interface.h"
+#include "bfdd/bfd_fsm.h"
+#include "bfdd/bfd_packet.h"
+
+#include "zebra/zserv.h"
+#include "zebra/zserv_bfd.h"
+
+extern struct thread_master *master;
+
+/* All information about zebra. */
+struct zclient *zclient = NULL;
+
+/* bfdd's interface node. */
+struct cmd_node interface_node = {
+  INTERFACE_NODE,
+  "%s(config-if)# ",
+  1
+};
+
+void
+bfd_zclient_reset (void)
+{
+  zclient_reset (zclient);
+};
+
+
+DEFUN (bfd_interval,
+       bfd_interval_cmd,
+       "bfd interval <200-30000> min_rx <200-30000> multiplier <1-20>",
+       "BFD configuration\n"
+       "desired transmit interval\n"
+       "msec\n"
+       "required minimum receive interval\n"
+       "msec\n" "detection multiplier\n")
+{
+  struct bfd_if_info *bii =
+    (struct bfd_if_info *) ((struct interface *) vty->index)->info;
+
+  u_int32_t interval = BFD_IF_INTERVAL_DFT;
+  u_int32_t minrx = BFD_IF_MINRX_DFT;
+  u_int32_t multi = BFD_IF_MULTIPLIER_DFT;
+
+  interval = atoi (argv[0]);
+  minrx = atoi (argv[1]);
+  multi = atoi (argv[2]);
+
+  if ((interval < BFD_IF_INTERVAL_MIN) || (interval > BFD_IF_INTERVAL_MAX))
+    {
+      vty_out (vty, "Interval is invalid%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+  if ((minrx < BFD_IF_MINRX_MIN) || (minrx > BFD_IF_MINRX_MAX))
+    {
+      vty_out (vty, "Min_rx is invalid%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+  if ((multi < BFD_IF_MULTIPLIER_MIN) || (multi > BFD_IF_MULTIPLIER_MAX))
+    {
+      vty_out (vty, "Multiplier is invalid%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  bii->interval = interval;
+  bii->minrx = minrx;
+  bii->multiplier = multi;
+
+  return CMD_SUCCESS;
+};
+
+static int
+bfd_passive_interface (struct vty *vty, int set)
+{
+  struct bfd_if_info *bii =
+    (struct bfd_if_info *) ((struct interface *) vty->index)->info;
+  if (bii)
+    {
+      bii->passive = set;
+      return CMD_SUCCESS;
+    }
+  return CMD_WARNING;
+}
+
+DEFUN (bfd_passive,
+       bfd_passive_cmd,
+       "bfd passive",
+       "BFD configuration\n" "Don't send BFD control packets first.\n")
+{
+  return bfd_passive_interface (vty, 1);
+};
+
+DEFUN (no_bfd_passive,
+       no_bfd_passive_cmd,
+       "no bfd passive",
+       NO_STR "BFD configuration\n" "Don't send BFD control packets first.\n")
+{
+  return bfd_passive_interface (vty, 0);
+};
+
+
+DEFUN (show_bfd_neighbors,
+       show_bfd_neighbors_cmd,
+       "show bfd neighbors", SHOW_STR BFD_STR "Show BFD neighbors\n")
+{
+  bfd_sh_bfd_neigh (vty, BFD_SH_NEIGH);
+  return CMD_SUCCESS;
+};
+
+DEFUN (show_bfd_neighbors_details,
+       show_bfd_neighbors_details_cmd,
+       "show bfd neighbors details", SHOW_STR BFD_STR "Show BFD neighbors\n")
+{
+  bfd_sh_bfd_neigh (vty, BFD_SH_NEIGH_DET);
+  return CMD_SUCCESS;
+};
+
+
+void
+bfd_sh_bfd_neigh_tbl (struct vty *vty, int mode,
+		      struct route_table *neightable, int *header)
+{
+  struct route_node *node, *subnode;
+
+  for (node = route_top (neightable); node != NULL; node = route_next (node))
+    if (!node->info)
+      continue;
+    else
+      for (subnode =
+	   route_top (((struct bfd_addrtreehdr *) node->info)->info);
+	   subnode != NULL; subnode = route_next (subnode))
+	if (!subnode->info)
+	  continue;
+	else
+	  {
+	    char buf[INET6_ADDRSTRLEN];
+	    char rbuf[INET6_ADDRSTRLEN];
+	    char lbuf[INET6_ADDRSTRLEN];
+
+	    struct bfd_neigh *neighp = (struct bfd_neigh *) subnode->info;
+
+	    snprintf (lbuf, sizeof (lbuf), "%s",
+		      sockunion2str (neighp->su_local, buf, sizeof (buf)));
+	    snprintf (rbuf, sizeof (rbuf), "%s",
+		      sockunion2str (neighp->su_remote, buf, sizeof (buf)));
+
+	    if (*header)
+	      {
+		vty_out (vty,
+			 "OutAddr          NeighAddr         LD/RD Holdown(mult) State     Int%s",
+			 VTY_NEWLINE);
+		*header = 0;
+	      }
+	    vty_out (vty, "%-16s %-16s %3u/%-3u %4u(%d) %9s %8s%s",
+		     lbuf, rbuf, neighp->ldisc, neighp->rdisc,
+		     MSEC (neighp->dtime), neighp->rmulti,
+		     bfd_state_str[neighp->lstate],
+		     ifindex2ifname (neighp->ifindex), VTY_NEWLINE);
+
+	    if (mode == BFD_SH_NEIGH_DET)
+	      {
+		vty_out (vty,
+			 "Local Diag: %u, Demand mode: %u, Poll bit: %u%s",
+			 neighp->ldiag, bfd_neigh_check_lbit_d (neighp),
+			 bfd_neigh_check_lbit_p (neighp), VTY_NEWLINE);
+		vty_out (vty, "MinTxInt: %u, MinRxInt: %u, Multiplier: %u%s",
+			 neighp->ldesmintx, neighp->lreqminrx, neighp->lmulti,
+			 VTY_NEWLINE);
+		vty_out (vty,
+			 "Received MinRxInt: %u, Received Multiplier: %u%s",
+			 neighp->rreqminrx, neighp->rmulti, VTY_NEWLINE);
+		vty_out (vty,
+			 "Holdown (hits): %u(%u), Hello (hits): %u(%u)%s",
+			 MSEC (neighp->dtime), neighp->timer_cnt,
+			 MSEC (neighp->negrxint), neighp->recv_cnt,
+			 VTY_NEWLINE);
+		vty_out (vty, "Rx Count: %u%s", neighp->recv_cnt,
+			 VTY_NEWLINE);
+		vty_out (vty, "Tx Count: %u%s", neighp->xmit_cnt,
+			 VTY_NEWLINE);
+		vty_out (vty,
+			 "Last packet: Version: %u               - Diagnostic: %u%s",
+			 neighp->rver, neighp->rdiag, VTY_NEWLINE);
+		vty_out (vty,
+			 "             State bit: %-9s     - Demand bit: %u%s",
+			 bfd_state_str[neighp->rstate],
+			 bfd_neigh_check_rbit_d (neighp), VTY_NEWLINE);
+		vty_out (vty,
+			 "             Poll bit: %-5u          - Final bit: %u%s",
+			 bfd_neigh_check_rbit_p (neighp),
+			 bfd_neigh_check_rbit_f (neighp), VTY_NEWLINE);
+		vty_out (vty,
+			 "             Multiplier: %-5u        - Length: %u%s",
+			 neighp->rmulti, neighp->rlen, VTY_NEWLINE);
+		vty_out (vty,
+			 "             My Discr: %-5u          - Your Discr: %-5u%s",
+			 neighp->ldisc, neighp->rdisc, VTY_NEWLINE);
+		vty_out (vty,
+			 "             Min tx interval: %-7u - Min rx interval: %u%s",
+			 neighp->rdesmintx, neighp->rreqminrx, VTY_NEWLINE);
+		vty_out (vty, "             Min Echo interval: %u%s%s",
+			 neighp->rreqminechorx, VTY_NEWLINE, VTY_NEWLINE);
+	      }
+	  }
+}
+
+void
+bfd_sh_bfd_neigh (struct vty *vty, int mode)
+{
+  int header = 1;
+  bfd_sh_bfd_neigh_tbl (vty, mode, neightbl->v4->raddr, &header);
+#ifdef HAVE_IPV6
+  bfd_sh_bfd_neigh_tbl (vty, mode, neightbl->v6->raddr, &header);
+#endif /* HAVE_IPV6 */
+}
+
+
+/* Configuration write function for bfdd. */
+static int
+config_write_interface (struct vty *vty)
+{
+  int write = 0;
+  struct listnode *node;
+  struct interface *ifp;
+  struct bfd_if_info *bii;
+
+  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))
+    {
+      /* IF name */
+      vty_out (vty, "interface %s%s", ifp->name, VTY_NEWLINE);
+      write++;
+      /* IF desc */
+      if (ifp->desc)
+	{
+	  vty_out (vty, " description %s%s", ifp->desc, VTY_NEWLINE);
+	  write++;
+	}
+      if (ifp->info)
+	{
+	  bii = ifp->info;
+	  if ((bii->interval != BFD_IF_INTERVAL_DFT)
+	      || (bii->minrx != BFD_IF_MINRX_DFT)
+	      || (bii->multiplier != BFD_IF_MULTIPLIER_DFT))
+	    vty_out (vty, " bfd interval %u min_rx %u multiplier %u%s",
+		     bii->interval, bii->minrx, bii->multiplier, VTY_NEWLINE);
+	  if (bii->passive)
+	    vty_out (vty, " bfd passive%s", VTY_NEWLINE);
+	}
+    }
+  return 0;
+}
+
+static int
+ipv4_bfd_neigh_up (int command, struct zclient *zclient, zebra_size_t length)
+{
+  struct bfd_cneigh *cneighp;
+
+  cneighp = ipv4_bfd_neigh_updown_read (zclient->ibuf);
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    BFD_ZEBRA_LOG_DEBUG_NOARG ("rcvd: ipv4_bfd_neigh_up")
+      bfd_cneigh_free (cneighp);
+  return 0;
+}
+
+static int
+ipv4_bfd_neigh_down (int command, struct zclient *zclient,
+		     zebra_size_t length)
+{
+  struct bfd_cneigh *cneighp;
+
+  cneighp = ipv4_bfd_neigh_updown_read (zclient->ibuf);
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    BFD_ZEBRA_LOG_DEBUG_NOARG ("rcvd: ipv4_bfd_neigh_down")
+      bfd_cneigh_free (cneighp);
+  return 0;
+}
+
+static int
+ipv4_bfd_cneigh_add (int command, struct zclient *zclient,
+		     zebra_size_t length)
+{
+  int ret;
+  struct bfd_cneigh *cneighp;
+
+  cneighp = ipv4_bfd_cneigh_adddel_read (zclient->ibuf);
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    BFD_ZEBRA_LOG_DEBUG_NOARG ("rcvd: ipv4_bfd_cneigh_add")
+      ret = bfd_neigh_add (bfd_cneigh_to_neigh (cneighp));
+  bfd_cneigh_free (cneighp);
+  return ret;
+
+}
+
+static int
+ipv4_bfd_cneigh_del (int command, struct zclient *zclient,
+		     zebra_size_t length)
+{
+  int ret;
+  struct bfd_cneigh *cneighp;
+
+  cneighp = ipv4_bfd_cneigh_adddel_read (zclient->ibuf);
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    BFD_ZEBRA_LOG_DEBUG_NOARG ("rcvd: ipv4_bfd_cneigh_del")
+      ret = bfd_cneigh_del (cneighp);
+  bfd_cneigh_free (cneighp);
+  return ret;
+}
+
+
+#ifdef HAVE_IPV6
+static int
+ipv6_bfd_neigh_up (int command, struct zclient *zclient, zebra_size_t length)
+{
+  struct bfd_cneigh *cneighp;
+
+  cneighp = ipv6_bfd_neigh_updown_read (zclient->ibuf);
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    BFD_ZEBRA_LOG_DEBUG_NOARG ("rcvd: ipv6_bfd_neigh_up")
+      bfd_cneigh_free (cneighp);
+  return 0;
+}
+
+static int
+ipv6_bfd_neigh_down (int command, struct zclient *zclient,
+		     zebra_size_t length)
+{
+  struct bfd_cneigh *cneighp;
+
+  cneighp = ipv6_bfd_neigh_updown_read (zclient->ibuf);
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    BFD_ZEBRA_LOG_DEBUG_NOARG ("rcvd: ipv6_bfd_neigh_down")
+      bfd_cneigh_free (cneighp);
+  return 0;
+}
+
+static int
+ipv6_bfd_cneigh_add (int command, struct zclient *zclient,
+		     zebra_size_t length)
+{
+  int ret;
+  struct bfd_cneigh *cneighp;
+
+  cneighp = ipv6_bfd_cneigh_adddel_read (zclient->ibuf);
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    BFD_ZEBRA_LOG_DEBUG_NOARG ("rcvd: ipv6_bfd_cneigh_add")
+      ret = bfd_neigh_add (bfd_cneigh_to_neigh (cneighp));
+  bfd_cneigh_free (cneighp);
+  return ret;
+
+}
+
+static int
+ipv6_bfd_cneigh_del (int command, struct zclient *zclient,
+		     zebra_size_t length)
+{
+  int ret;
+  struct bfd_cneigh *cneighp;
+
+  cneighp = ipv6_bfd_cneigh_adddel_read (zclient->ibuf);
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    BFD_ZEBRA_LOG_DEBUG_NOARG ("rcvd: ipv6_bfd_cneigh_del")
+      ret = bfd_cneigh_del (cneighp);
+  bfd_cneigh_free (cneighp);
+  return ret;
+}
+#endif /* HAVE_IPV6 */
+
+
+static int
+bfd_interface_add (int command, struct zclient *zclient, zebra_size_t length)
+{
+  struct interface *ifp;
+
+  ifp = zebra_interface_add_read (zclient->ibuf);
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    zlog_debug ("Zebra rcvd: interface add %s", ifp->name);
+
+  return 0;
+}
+
+static int
+bfd_interface_delete (int command, struct zclient *zclient,
+		      zebra_size_t length)
+{
+  struct stream *s;
+  struct interface *ifp;
+
+  s = zclient->ibuf;
+  ifp = zebra_interface_state_read (s);
+  ifp->ifindex = IFINDEX_INTERNAL;
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    zlog_debug ("Zebra rcvd: interface delete %s", ifp->name);
+
+  return 0;
+}
+
+static int
+bfd_interface_up (int command, struct zclient *zclient, zebra_size_t length)
+{
+  struct stream *s;
+  struct interface *ifp;
+
+  s = zclient->ibuf;
+  ifp = zebra_interface_state_read (s);
+
+  if (!ifp)
+    return 0;
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    zlog_debug ("Zebra rcvd: interface %s up", ifp->name);
+
+  return 0;
+}
+
+static int
+bfd_interface_down (int command, struct zclient *zclient, zebra_size_t length)
+{
+  struct stream *s;
+  struct interface *ifp;
+
+  s = zclient->ibuf;
+  ifp = zebra_interface_state_read (s);
+  if (!ifp)
+    return 0;
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    zlog_debug ("Zebra rcvd: interface %s down", ifp->name);
+  return 0;
+}
+
+static int
+bfd_interface_address_add (int command, struct zclient *zclient,
+			   zebra_size_t length)
+{
+  struct connected *ifc;
+
+  ifc = zebra_interface_address_read (command, zclient->ibuf);
+
+  if (ifc == NULL)
+    return 0;
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    {
+      char buf[128];
+      prefix2str (ifc->address, buf, sizeof (buf));
+      zlog_debug ("Zebra rcvd: interface %s address add %s",
+		  ifc->ifp->name, buf);
+    }
+  return 0;
+}
+
+static int
+bfd_interface_address_delete (int command, struct zclient *zclient,
+			      zebra_size_t length)
+{
+  struct connected *ifc;
+
+  ifc = zebra_interface_address_read (command, zclient->ibuf);
+
+  if (ifc == NULL)
+    return 0;
+
+  if (BFD_IF_DEBUG_ZEBRA)
+    {
+      char buf[128];
+      prefix2str (ifc->address, buf, sizeof (buf));
+      zlog_debug ("Zebra rcvd: interface %s address delete %s",
+		  ifc->ifp->name, buf);
+    }
+
+  connected_free (ifc);
+
+  return 0;
+}
+
+void
+bfd_signal_neigh_updown (struct bfd_neigh *neighp, int cmd)
+{
+  struct prefix *raddr = sockunion2hostprefix (neighp->su_remote);
+  struct prefix *laddr = sockunion2hostprefix (neighp->su_local);
+
+  if (bfd_check_neigh_family (neighp) == AF_INET)
+    zapi_ipv4_bfd_neigh_updown (zclient,
+				cmd,
+				(struct prefix_ipv4 *) raddr,
+				(struct prefix_ipv4 *) laddr,
+				neighp->ifindex);
+#ifdef HAVE_IPV6
+  else
+    zapi_ipv6_bfd_neigh_updown (zclient,
+				cmd,
+				(struct prefix_ipv6 *) raddr,
+				(struct prefix_ipv6 *) laddr,
+				neighp->ifindex);
+#endif /* HAVE_IPV6 */
+}
+
+
+
+/* Initialization of BFD interface. */
+static void
+bfd_vty_cmd_init (void)
+{
+
+  /* Initialize Zebra interface data structure */
+  if_init ();
+
+  /* Install interface node. */
+  install_node (&interface_node, config_write_interface);
+
+  install_element (VIEW_NODE, &show_bfd_neighbors_details_cmd);
+  install_element (ENABLE_NODE, &show_bfd_neighbors_details_cmd);
+
+  install_element (VIEW_NODE, &show_bfd_neighbors_cmd);
+  install_element (ENABLE_NODE, &show_bfd_neighbors_cmd);
+
+  install_element (CONFIG_NODE, &interface_cmd);
+  install_element (CONFIG_NODE, &no_interface_cmd);
+  install_default (INTERFACE_NODE);
+  install_element (INTERFACE_NODE, &bfd_interval_cmd);
+  install_element (INTERFACE_NODE, &bfd_passive_cmd);
+  install_element (INTERFACE_NODE, &no_bfd_passive_cmd);
+};
+
+
+void
+bfd_vty_init (void)
+{
+  bfd_vty_cmd_init ();
+  bfd_vty_debug_init ();
+};
+
+void
+bfd_zebra_init (void)
+{
+  zclient = zclient_new ();
+  zclient_init (zclient, ZEBRA_ROUTE_BFD);	/* FIXME */
+  zclient->flags = ZCLIENT_FLAGS_BFDD;
+
+  /* Callback functions */
+  zclient->interface_add = bfd_interface_add;
+  zclient->interface_delete = bfd_interface_delete;
+  zclient->interface_address_add = bfd_interface_address_add;
+  zclient->interface_address_delete = bfd_interface_address_delete;
+  zclient->interface_up = bfd_interface_up;
+  zclient->interface_down = bfd_interface_down;
+  zclient->ipv4_bfd_cneigh_add = ipv4_bfd_cneigh_add;
+  zclient->ipv4_bfd_cneigh_del = ipv4_bfd_cneigh_del;
+  zclient->ipv4_bfd_neigh_up = ipv4_bfd_neigh_up;
+  zclient->ipv4_bfd_neigh_down = ipv4_bfd_neigh_down;
+#ifdef HAVE_IPV6
+  zclient->ipv6_bfd_cneigh_add = ipv6_bfd_cneigh_add;
+  zclient->ipv6_bfd_cneigh_del = ipv6_bfd_cneigh_del;
+  zclient->ipv6_bfd_neigh_up = ipv6_bfd_neigh_up;
+  zclient->ipv6_bfd_neigh_down = ipv6_bfd_neigh_down;
+#endif /* HAVE_IPV6 */
+}
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/bfd_zebra.h quagga-0.99.9-bfd-0.90.1/bfdd/bfd_zebra.h
--- quagga-0.99.9/bfdd/bfd_zebra.h	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/bfd_zebra.h	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,47 @@
+/*
+ * BFDD - bfd_zebra.h   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef _QUAGGA_BFD_ZEBRA_H
+#define _QUAGGA_BFD_ZEBRA_H
+
+
+#include "zebra.h"
+#include "zclient.h"
+#include "sockunion.h"
+
+void bfd_vty_init (void);
+void bfd_zebra_init (void);
+
+void bfd_zclient_reset (void);
+
+#define BFD_SH_NEIGH      0
+#define BFD_SH_NEIGH_DET  1
+void bfd_sh_bfd_neigh (struct vty *vty, int mode);
+void bfd_sh_bfd_neigh_tbl (struct vty *vty, int mode,
+			   struct route_table *neightable, int *header);
+
+void bfd_signal_neigh_updown (struct bfd_neigh *neighp, int cmd);
+#define bfd_signal_neigh_up(NEIGH) \
+        bfd_signal_neigh_updown(NEIGH,BFD_NEIGH_UP)
+#define bfd_signal_neigh_down(NEIGH) \
+        bfd_signal_neigh_updown(NEIGH,BFD_NEIGH_DOWN)
+
+#endif /* _QUAGGA_BFD_ZEBRA_H */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/bfdd/Makefile.am quagga-0.99.9-bfd-0.90.1/bfdd/Makefile.am
--- quagga-0.99.9/bfdd/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/bfdd/Makefile.am	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,25 @@
+## Process this file with automake to produce Makefile.in.
+
+INCLUDES = @INCLUDES@ -I.. -I$(top_srcdir) -I$(top_srcdir)/lib
+DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\"
+INSTALL_SDATA=@INSTALL@ -m 600
+
+noinst_LIBRARIES = libbfd.a
+sbin_PROGRAMS = bfdd
+
+libbfd_a_SOURCES = \
+	bfdd.c bfd_debug.c bfd_fsm.c bfd_interface.c bfd_net.c \
+        bfd_packet.c bfd_zebra.c
+
+noinst_HEADERS = \
+	bfdd.h bfd_debug.h bfd_fsm.h bfd_interface.h bfd_net.h \
+        bfd_packet.h bfd_zebra.h
+
+bfdd_SOURCES = \
+	bfd_main.c $(libbfd_a_SOURCES)
+
+bfdd_LDADD = ../lib/libzebra.la @LIBCAP@
+
+examplesdir = $(exampledir)
+dist_examples_DATA = bfdd.conf.sample
+
diff -Nupwbr --exclude=bgpd quagga-0.99.9/configure.ac quagga-0.99.9-bfd-0.90.1/configure.ac
--- quagga-0.99.9/configure.ac	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/configure.ac	2007-10-21 01:09:15.000000000 +0200
@@ -183,6 +183,8 @@ AC_ARG_ENABLE(ipv6,
 [  --disable-ipv6          turn off IPv6 related features and daemons])
 AC_ARG_ENABLE(zebra,
 [  --disable-zebra         do not build zebra daemon])
+AC_ARG_ENABLE(bfdd,
+[  --disable-bfdd          do not build bfdd])
 AC_ARG_ENABLE(bgpd,
 [  --disable-bgpd          do not build bgpd])
 AC_ARG_ENABLE(ripd,
@@ -1108,6 +1110,12 @@ else
   ZEBRA="zebra"
 fi
 
+if test "${enable_bfdd}" = "no";then
+  BFDD=""
+else
+  BFDD="bfdd"
+fi
+
 if test "${enable_bgpd}" = "no";then
   BGPD=""
 else
@@ -1174,6 +1182,7 @@ if test "${enable_bgp_announce}" = "no";
 fi
 
 AC_SUBST(ZEBRA)
+AC_SUBST(BFDD)
 AC_SUBST(BGPD)
 AC_SUBST(RIPD)
 AC_SUBST(RIPNGD)
@@ -1390,6 +1399,7 @@ fi
 AC_DEFINE_UNQUOTED(PATH_ZEBRA_PID, "$quagga_statedir/zebra.pid",zebra PID)
 AC_DEFINE_UNQUOTED(PATH_RIPD_PID, "$quagga_statedir/ripd.pid",ripd PID)
 AC_DEFINE_UNQUOTED(PATH_RIPNGD_PID, "$quagga_statedir/ripngd.pid",ripngd PID)
+AC_DEFINE_UNQUOTED(PATH_BFDD_PID, "$quagga_statedir/bfdd.pid",bfdd PID)
 AC_DEFINE_UNQUOTED(PATH_BGPD_PID, "$quagga_statedir/bgpd.pid",bgpd PID)
 AC_DEFINE_UNQUOTED(PATH_OSPFD_PID, "$quagga_statedir/ospfd.pid",ospfd PID)
 AC_DEFINE_UNQUOTED(PATH_OSPF6D_PID, "$quagga_statedir/ospf6d.pid",ospf6d PID)
@@ -1399,6 +1409,7 @@ AC_DEFINE_UNQUOTED(ZEBRA_SERV_PATH, "$qu
 AC_DEFINE_UNQUOTED(ZEBRA_VTYSH_PATH, "$quagga_statedir/zebra.vty",zebra vty socket)
 AC_DEFINE_UNQUOTED(RIP_VTYSH_PATH, "$quagga_statedir/ripd.vty",rip vty socket)
 AC_DEFINE_UNQUOTED(RIPNG_VTYSH_PATH, "$quagga_statedir/ripngd.vty",ripng vty socket)
+AC_DEFINE_UNQUOTED(BFD_VTYSH_PATH, "$quagga_statedir/bfdd.vty",bfdd vty socket)
 AC_DEFINE_UNQUOTED(BGP_VTYSH_PATH, "$quagga_statedir/bgpd.vty",bgpd vty socket)
 AC_DEFINE_UNQUOTED(OSPF_VTYSH_PATH, "$quagga_statedir/ospfd.vty",ospfd vty socket)
 AC_DEFINE_UNQUOTED(OSPF6_VTYSH_PATH, "$quagga_statedir/ospf6d.vty",ospf6d vty socket)
@@ -1425,15 +1436,16 @@ AC_CACHE_VAL(ac_cv_htonl_works,
 AC_MSG_RESULT($ac_cv_htonl_works)
 
 AC_CONFIG_FILES([Makefile lib/Makefile zebra/Makefile ripd/Makefile 
-	  ripngd/Makefile bgpd/Makefile ospfd/Makefile watchquagga/Makefile
-	  ospf6d/Makefile isisd/Makefile vtysh/Makefile doc/Makefile 
-	  ospfclient/Makefile tests/Makefile m4/Makefile redhat/Makefile
+	  ripngd/Makefile bfdd/Makefile bgpd/Makefile ospfd/Makefile 
+	  watchquagga/Makefile ospf6d/Makefile isisd/Makefile vtysh/Makefile 
+	  doc/Makefile ospfclient/Makefile tests/Makefile m4/Makefile
+	  redhat/Makefile
 	  pkgsrc/Makefile
 	  redhat/quagga.spec 
 	  lib/version.h
 	  doc/defines.texi
 	  isisd/topology/Makefile
-	  pkgsrc/bgpd.sh pkgsrc/ospf6d.sh pkgsrc/ospfd.sh
+	  pkgsrc/bfdd.sh pkgsrc/bgpd.sh pkgsrc/ospf6d.sh pkgsrc/ospfd.sh
 	  pkgsrc/ripd.sh pkgsrc/ripngd.sh pkgsrc/zebra.sh])
 AC_CONFIG_FILES([solaris/Makefile])
 
diff -Nupwbr --exclude=bgpd quagga-0.99.9/configure.ac.orig quagga-0.99.9-bfd-0.90.1/configure.ac.orig
--- quagga-0.99.9/configure.ac.orig	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/configure.ac.orig	2007-10-21 01:03:58.000000000 +0200
@@ -0,0 +1,1473 @@
+##
+## Configure template file for Quagga.
+## autoconf will generate configure script.
+##
+##  Copyright (c) 1996, 97, 98, 99, 2000 Kunihiro Ishiguro <kunihiro@zebra.org>
+##  Portions Copyright (c) 2003 Paul Jakma <paul@dishone.st>
+##
+## $Id: configure.ac,v 1.139 2007/09/07 16:54:01 paul Exp $
+AC_PREREQ(2.53)
+
+AC_INIT(Quagga, 0.99.9, [http://bugzilla.quagga.net])
+AC_CONFIG_SRCDIR(lib/zebra.h)
+
+dnl -----------------------------------
+dnl Get hostname and other information.
+dnl -----------------------------------
+AC_CANONICAL_BUILD()
+AC_CANONICAL_HOST()
+AC_CANONICAL_TARGET()
+
+AM_INIT_AUTOMAKE(1.6)
+AM_CONFIG_HEADER(config.h)
+
+dnl GNU awk is required for lib/memtype.h made by memtypes.awk.
+dnl BSD awk complains: awk: gensub doesn't support backreferences (subst "\1")
+AC_CHECK_PROG([GAWK],[gawk],[gawk],[/bin/false])
+AC_ARG_VAR([GAWK],[GNU AWK])
+
+dnl default is to match previous behavior
+exampledir=${sysconfdir}
+AC_ARG_ENABLE([exampledir],
+	  AC_HELP_STRING([--enable-exampledir],
+			 [specify alternate directory for examples]),
+			 exampledir="$enableval",)
+dnl XXX add --exampledir to autoconf standard directory list somehow
+AC_SUBST(exampledir)
+
+dnl default is to match previous behavior
+pkgsrcrcdir=""
+pkgsrcdir=""
+AC_ARG_ENABLE([pkgsrcrcdir],
+	  AC_HELP_STRING([--enable-pkgsrcrcdir],
+			 [specify directory for rc.d scripts]),
+			 pkgsrcrcdir="$enableval"; pkgsrcdir="pkgsrc",)
+dnl XXX add --pkgsrcrcdir to autoconf standard directory list somehow
+AC_SUBST(pkgsrcdir)
+AC_SUBST(pkgsrcrcdir)
+
+dnl ------------
+dnl Check CFLAGS
+dnl ------------
+AC_ARG_WITH(cflags,
+[  --with-cflags           Set CFLAGS for use in compilation.])
+if test "x$with_cflags" != "x" ; then
+  CFLAGS="$with_cflags" ; cflags_specified=yes ;
+elif test -n "$CFLAGS" ; then
+  cflags_specified=yes ;
+fi
+
+dnl --------------------
+dnl Check CC and friends
+dnl --------------------
+AC_PROG_CC
+AC_PROG_CPP
+
+AC_PROG_EGREP
+
+dnl autoconf 2.59 appears not to support AC_PROG_SED
+dnl AC_PROG_SED
+AC_CHECK_PROG([SED],[sed],[sed],[/bin/false])
+
+dnl ------------------------------------------------------------------
+dnl Intel compiler check. Although Intel tries really hard to make icc
+dnl look like gcc, there are some differences. It's very verbose with
+dnl -Wall and it doesn't support the individual -W options.
+dnl ------------------------------------------------------------------
+if test "x${GCC}" = "xyes" ; then
+  COMPILER="GCC"
+  AC_MSG_CHECKING([whether we are using the Intel compiler])
+  AC_EGREP_CPP([^__INTEL_COMPILER], [__INTEL_COMPILER],
+      [AC_MSG_RESULT([no])],
+      [COMPILER="ICC"
+       AC_MSG_RESULT([yes])]
+  )
+else
+  AC_MSG_CHECKING([whether we are using SunPro compiler])
+  AC_EGREP_CPP([^__SUNPRO_C.*0x5(7|8|9)], ["__SUNPRO_C" __SUNPRO_C],
+      [AC_MSG_RESULT([no])],
+      [COMPILER="SUNPRO"
+       AC_MSG_RESULT([yes])]
+  )
+fi
+
+dnl ---------------------------------------------
+dnl If CLFAGS doesn\'t exist set default value
+dnl AC_PROG_CC will have set minimal default
+dnl already, eg "-O2 -g" for gcc, "-g" for others
+dnl (Wall is gcc specific... have to make sure
+dnl  gcc is being used before setting it)
+dnl
+dnl Intel icc 8.0 also sets __GNUC__, 
+dnl but doesn't support all these fancy -W options.
+dnl Intel compiler warnings we ignore:
+dnl 279: controlling expression is constant.
+dnl 869: parameter "xxx" was never referenced - to avoid massive warnings
+dnl      about "self", "vty", "argc" and "argv" never referenced in DEFUN
+dnl      macro.
+dnl 981: operands are evaluated in unspecified order.
+dnl
+dnl Sun Studio 10 / SunPro 5.7 is also supported,
+dnl so lets set some sane CFLAGS for it.
+dnl ---------------------------------------------
+
+AC_MSG_CHECKING([whether to set a default CFLAGS])
+if test "x${cflags_specified}" = "x" ; then
+  case ${COMPILER} in
+    "ICC")
+        CFLAGS="-Os -g -Wall -wd 279,869,981"
+        AC_MSG_RESULT([Intel default])
+        ;;
+    "GCC")
+  	CFLAGS="-Os -fno-omit-frame-pointer -g -std=gnu99 -Wall"
+  	CFLAGS="${CFLAGS} -Wsign-compare -Wpointer-arith"
+  	CFLAGS="${CFLAGS} -Wbad-function-cast -Wwrite-strings"
+  	CFLAGS="${CFLAGS} -Wmissing-prototypes -Wmissing-declarations"
+  	CFLAGS="${CFLAGS} -Wchar-subscripts -Wcast-qual"
+  	# TODO: conditionally addd -Wpacked if handled
+  	AC_MSG_RESULT([gcc default])
+  	;;
+    "SUNPRO")
+  	CFLAGS="-xO4 -v -g -xspace -xcode=pic32 -xstrconst -xc99"
+  	AC_MSG_RESULT([SunPro default])
+  	;;
+    *)
+        AC_MSG_RESULT([unknown compiler])
+        ;;
+  esac
+else
+  AC_MSG_RESULT([CFLAGS supplied by user])
+fi
+
+dnl --------------
+dnl Check programs
+dnl --------------
+AC_PROG_INSTALL
+AC_PROG_LN_S
+AC_PROG_MAKE_SET
+AC_CHECK_TOOL(AR, ar)
+
+dnl ---------------------------
+dnl We, perhaps unfortunately,
+dnl depend on GNU Make specific
+dnl constructs.
+dnl Give the user a warning if
+dnl not GNU Make.
+dnl ---------------------------
+AC_CACHE_CHECK([if ${MAKE-make} is GNU make], [quagga_cv_gnu_make],
+	[quagga_cv_gnu_make=no
+	 if ${MAKE-make} --version 2>/dev/null | \
+	 	grep '^GNU Make ' >/dev/null ; then
+	 	quagga_cv_gnu_make=yes;
+	 fi
+	]
+)
+
+dnl -----------------
+dnl System extensions
+dnl -----------------
+AC_AIX
+AC_GNU_SOURCE
+
+dnl -------
+dnl libtool
+dnl -------
+AC_PROG_LIBTOOL
+
+dnl ----------------------
+dnl Packages configuration
+dnl ----------------------
+AC_ARG_ENABLE(vtysh,
+[  --enable-vtysh          include integrated vty shell for Quagga])
+AC_ARG_ENABLE(ipv6,
+[  --disable-ipv6          turn off IPv6 related features and daemons])
+AC_ARG_ENABLE(zebra,
+[  --disable-zebra         do not build zebra daemon])
+AC_ARG_ENABLE(bgpd,
+[  --disable-bgpd          do not build bgpd])
+AC_ARG_ENABLE(ripd,
+[  --disable-ripd          do not build ripd])
+AC_ARG_ENABLE(ripngd,
+[  --disable-ripngd        do not build ripngd])
+AC_ARG_ENABLE(ospfd,
+[  --disable-ospfd         do not build ospfd])
+AC_ARG_ENABLE(ospf6d,
+[  --disable-ospf6d        do not build ospf6d])
+AC_ARG_ENABLE(watchquagga,
+[  --disable-watchquagga   do not build watchquagga])
+AC_ARG_ENABLE(isisd,
+[  --enable-isisd          build isisd])
+AC_ARG_ENABLE(solaris,
+[  --enable-solaris          build solaris])
+AC_ARG_ENABLE(bgp-announce,
+[  --disable-bgp-announce, turn off BGP route announcement])
+AC_ARG_ENABLE(netlink,
+[  --enable-netlink        force to use Linux netlink interface])
+AC_ARG_ENABLE(broken-aliases,
+[  --enable-broken-aliases enable aliases as distinct interfaces for Linux 2.2.X])
+AC_ARG_ENABLE(snmp,
+[  --enable-snmp           enable SNMP support])
+AC_ARG_WITH(libpam,
+[  --with-libpam           use libpam for PAM support in vtysh])
+AC_ARG_ENABLE(tcp-zebra,
+[  --enable-tcp-zebra      enable TCP/IP socket connection between zebra and protocol daemon])
+AC_ARG_ENABLE(opaque-lsa,
+[  --enable-opaque-lsa     enable OSPF Opaque-LSA with OSPFAPI support (RFC2370)])
+AC_ARG_ENABLE(ospfapi,
+[  --disable-ospfapi       do not build OSPFAPI to access the OSPF LSA Database, 
+                          (this is the default if --enable-opaque-lsa is not set)])
+AC_ARG_ENABLE(ospfclient,
+[  --disable-ospfclient    do not build OSPFAPI client for OSPFAPI, 
+                          (this is the default if --disable-ospfapi is set)])
+AC_ARG_ENABLE(ospf-te,
+[  --enable-ospf-te        enable Traffic Engineering Extension to OSPF])
+AC_ARG_ENABLE(multipath,
+[  --enable-multipath=ARG  enable multipath function, ARG must be digit])
+AC_ARG_ENABLE(quagga_user,
+[  --enable-user=ARG       user to run Quagga suite as (default quagga)])
+AC_ARG_ENABLE(quagga_group,
+[  --enable-group=ARG      group to run Quagga suite as (default quagga)])
+AC_ARG_ENABLE(vty_group,
+[  --enable-vty-group=ARG  set vty sockets to have specified group as owner])
+AC_ARG_ENABLE(configfile_mask,
+[  --enable-configfile-mask=ARG  set mask for config files])
+AC_ARG_ENABLE(logfile_mask,
+[  --enable-logfile-mask=ARG     set mask for log files])
+
+AC_ARG_ENABLE(rtadv,
+[  --disable-rtadv               disable IPV6 router advertisement feature])
+AC_ARG_ENABLE(irdp,
+[  --enable-irdp                 enable IRDP server support in zebra])
+AC_ARG_ENABLE(isis_topology,
+[  --enable-isis-topology        enable IS-IS topology generator])
+AC_ARG_ENABLE(capabilities,
+[  --disable-capabilities        disable using POSIX capabilities])
+AC_ARG_ENABLE(gcc_ultra_verbose,
+[  --enable-gcc-ultra-verbose    enable ultra verbose GCC warnings])
+AC_ARG_ENABLE(gcc-rdynamic,
+[  --enable-gcc-rdynamic   enable gcc linking with -rdynamic for better backtraces])
+AC_ARG_ENABLE(time-check,
+[  --disable-time-check          disable slow thread warning messages])
+
+if test x"${enable_gcc_ultra_verbose}" = x"yes" ; then
+  CFLAGS="${CFLAGS} -W -Wcast-qual -Wstrict-prototypes"
+  CFLAGS="${CFLAGS} -Wmissing-declarations -Wmissing-noreturn"
+  CFLAGS="${CFLAGS} -Wmissing-format-attribute -Wunreachable-code"
+  CFLAGS="${CFLAGS} -Wpacked -Wpadded"
+fi
+
+if test x"${enable_gcc_rdynamic}" = x"yes" ; then
+  LDFLAGS="${LDFLAGS} -rdynamic"
+fi
+
+if test x"${enable_time_check}" != x"no" ; then
+  if test x"${enable_time_check}" = x"yes" -o x"${enable_time_check}" = x ; then
+    AC_DEFINE(CONSUMED_TIME_CHECK,5000000,Consumed Time Check)
+  else
+    AC_DEFINE_UNQUOTED(CONSUMED_TIME_CHECK,$enable_time_check,Consumed Time Check)
+  fi
+fi
+
+if test "${enable_broken_aliases}" = "yes"; then
+  if test "${enable_netlink}" = "yes"
+  then
+    AC_MSG_FAILURE([Sorry you can not use netlink with broken aliases])
+  fi
+  AC_DEFINE(HAVE_BROKEN_ALIASES,,Broken Alias)
+  enable_netlink=no
+fi
+
+if test "${enable_tcp_zebra}" = "yes"; then
+  AC_DEFINE(HAVE_TCP_ZEBRA,,Use TCP for zebra communication)
+fi
+
+if test "${enable_opaque_lsa}" = "yes"; then
+  AC_DEFINE(HAVE_OPAQUE_LSA,,OSPF Opaque LSA)
+fi
+
+if test "${enable_ospf_te}" = "yes"; then
+  AC_DEFINE(HAVE_OPAQUE_LSA,,OSPF Opaque LSA)
+  AC_DEFINE(HAVE_OSPF_TE,,OSPF TE)
+fi
+
+AC_MSG_CHECKING(if zebra should be configurable to send Route Advertisements)
+if test "${enable_rtadv}" != "no"; then
+  AC_MSG_RESULT(yes)
+  AC_DEFINE(HAVE_RTADV,,Enable IPv6 Routing Advertisement support)
+else
+  AC_MSG_RESULT(no)
+fi
+
+if test "${enable_irdp}" = "yes"; then
+  AC_DEFINE(HAVE_IRDP,, IRDP )
+fi
+
+if test "${enable_isisd}" = "yes" && test "${enable_isis_topology}" = yes; then
+  AC_DEFINE(TOPOLOGY_GENERATE,,Enable IS-IS topology generator code)
+  ISIS_TOPOLOGY_INCLUDES="-I./topology"
+  ISIS_TOPOLOGY_DIR="topology"
+  ISIS_TOPOLOGY_LIB="./topology/libtopology.a"
+fi
+
+AC_SUBST(ISIS_TOPOLOGY_INCLUDES)
+AC_SUBST(ISIS_TOPOLOGY_DIR)
+AC_SUBST(ISIS_TOPOLOGY_LIB)
+
+if test "${enable_user}" = "yes" || test x"${enable_user}" = x""; then
+  enable_user="quagga"
+elif test "${enable_user}" = "no"; then
+  enable_user="root"
+fi
+
+if test "${enable_group}" = "yes" || test x"${enable_group}" = x""; then
+  enable_group="quagga"
+elif test "${enable_group}" = "no"; then
+  enable_group="root"
+fi
+
+if test x"${enable_vty_group}" = x"yes" ; then
+  AC_MSG_ERROR([--enable-vty-group requires a group as argument, not yes])
+elif test x"${enable_vty_group}" != x""; then
+  if test x"${enable_vty_group}" != x"no"; then
+    AC_DEFINE_UNQUOTED(VTY_GROUP, "${enable_vty_group}", VTY Sockets Group)
+  fi
+fi
+AC_SUBST([enable_user])
+AC_SUBST([enable_group])
+AC_SUBST([enable_vty_group])
+AC_DEFINE_UNQUOTED(QUAGGA_USER, "${enable_user}", Quagga User)
+AC_DEFINE_UNQUOTED(QUAGGA_GROUP, "${enable_group}", Quagga Group)
+
+enable_configfile_mask=${enable_configfile_mask:-0600}
+AC_DEFINE_UNQUOTED(CONFIGFILE_MASK, ${enable_configfile_mask}, Mask for config files)
+
+enable_logfile_mask=${enable_logfile_mask:-0600}
+AC_DEFINE_UNQUOTED(LOGFILE_MASK, ${enable_logfile_mask}, Mask for log files)
+
+MULTIPATH_NUM=1
+
+case "${enable_multipath}" in
+  [[0-9]|[1-9][0-9]])
+    MULTIPATH_NUM="${enable_multipath}"
+    ;;
+  "")
+    ;;
+  *)           
+    AC_MSG_FAILURE([Please specify digit to enable multipath ARG])
+    ;;
+esac
+
+AC_SUBST(MULTIPATH_NUM)
+
+dnl ------------------------------------
+dnl Check C keywords and standard  types
+dnl ------------------------------------
+AC_C_CONST
+AC_C_INLINE
+AC_C_RESTRICT
+AC_C_VOLATILE
+AC_HEADER_STDC
+AC_HEADER_TIME
+AC_HEADER_SYS_WAIT
+dnl AC_TYPE_PID_T
+AC_TYPE_UID_T
+AC_TYPE_MODE_T
+AC_TYPE_SIZE_T
+AC_TYPE_SIGNAL
+AC_STRUCT_TM
+
+dnl -------------------------
+dnl Check other header files.
+dnl -------------------------
+AC_CHECK_HEADERS([stropts.h sys/ksym.h sys/times.h sys/select.h \
+	sys/types.h linux/version.h netdb.h asm/types.h \
+	sys/param.h limits.h signal.h libutil.h \
+	sys/socket.h netinet/in.h])
+
+dnl Utility macro to avoid retyping includes all the time
+m4_define([QUAGGA_INCLUDES],
+[#ifdef SUNOS_5
+#define _XPG4_2
+#define __EXTENSIONS__
+#endif
+#include <stdio.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# if HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+/* sys/conf.h depends on param.h on FBSD at least */
+#if HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+/* Required for MAXSIG */
+#if HAVE_SIGNAL_H
+# include <signal.h>
+#endif
+#if HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
+#if HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif
+])dnl
+
+AC_CHECK_HEADERS([sys/un.h net/if.h netinet/in_systm.h netinet/in_var.h \
+	net/if_dl.h net/if_var.h net/netopt.h net/route.h \
+	inet/nd.h arpa/inet.h netinet/ip_icmp.h \
+	fcntl.h stddef.h sys/ioctl.h syslog.h wchar.h wctype.h \
+	sys/sysctl.h sys/sockio.h kvm.h sys/conf.h],
+	[], [], QUAGGA_INCLUDES)
+
+AC_CHECK_HEADERS([ucontext.h], [], [],
+[#ifndef __USE_GNU
+#define __USE_GNU
+#endif /* __USE_GNU */
+QUAGGA_INCLUDES
+])
+
+m4_define([QUAGGA_INCLUDES],
+QUAGGA_INCLUDES
+[#if HAVE_NET_IF_H
+# include <net/if.h>
+#endif
+#if HAVE_SYS_UN_H
+# include <sys/un.h>
+#endif
+#if HAVE_NETINET_IN_SYSTM_H
+# include <netinet/in_systm.h>
+#endif
+#if HAVE_NETINET_IN_VAR_H
+# include <netinet/in_var.h>
+#endif
+#if HAVE_NET_IF_DL_H
+# include <net/if_dl.h>
+#endif
+#if HAVE_NET_IF_VAR_H
+# include <net/if_var.h>
+#endif
+#if HAVE_NET_NETOPT_H
+# include <net/netopt.h>
+#endif
+#if HAVE_NET_ROUTE_H
+# include <net/route.h>
+#endif
+#if HAVE_INET_ND_H
+# include <inet/nd.h>
+#endif
+#if HAVE_ARPA_INET_H
+# include <arpa/inet.h>
+#endif
+/* Required for IDRP */
+#if HAVE_NETINET_IP_ICMP_H
+# include <netinet/ip_icmp.h>
+#endif
+])dnl
+
+dnl V6 headers are checked below, after we check for v6
+
+dnl Some systems (Solaris 2.x) require libnsl (Network Services Library)
+case "$host" in
+  [*-sunos5.[6-7]*] | [*-solaris2.[6-7]*])
+      opsys=sol2-6
+      AC_DEFINE(SUNOS_56, 1, SunOS 5.6 to 5.7)
+      AC_DEFINE(SUNOS_5, 1, SunOS 5)
+      AC_CHECK_LIB(xnet, main)
+      CURSES=-lcurses
+  ;;
+  [*-sunos5.[8-9]] \
+  | [*-sunos5.1[0-9]] \
+  | [*-sunos5.1[0-9].[0-9]] \
+  | [*-solaris2.[8-9]] \
+  | [*-solaris2.1[0-9]] \
+  | [*-solaris2.1[0-9].[0-9]])
+      opsys=sol8
+      AC_DEFINE(SUNOS_59, 1, [SunOS 5.8 up])
+      AC_DEFINE(SUNOS_5, 1, [SunOS 5])
+      AC_CHECK_LIB(socket, main)
+      AC_CHECK_LIB(nsl, main)
+      AC_CHECK_LIB(umem, main)
+      AC_CHECK_FUNCS([printstack],
+      	[AC_DEFINE([HAVE_PRINTSTACK],1,[Solaris printstack])
+      	 AC_DEFINE([HAVE_STACK_TRACE],1,[Stack symbols decode functionality])
+      	])
+      CURSES=-lcurses
+  ;;
+  *-sunos5* | *-solaris2*)
+      AC_DEFINE(SUNOS_5,,SunOS 5, Unknown SunOS)
+      AC_CHECK_LIB(socket, main)
+      AC_CHECK_LIB(nsl, main)
+      CURSES=-lcurses
+  ;;
+  *-linux*)
+      opsys=gnu-linux
+      AC_DEFINE(GNU_LINUX,,GNU Linux)
+  ;;
+  *-nec-sysv4*)
+      AC_CHECK_LIB(nsl, gethostbyname)
+      AC_CHECK_LIB(socket, socket)
+  ;;
+  *-openbsd*)
+      opsys=openbsd
+      AC_DEFINE(OPEN_BSD,,OpenBSD)
+  ;;
+  *-bsdi*)
+      opsys=bsdi
+      OTHER_METHOD="mtu_kvm.o"
+      AC_CHECK_LIB(kvm, main)
+  ;;
+  *-irix6.5)
+      opsys=irix
+      AC_DEFINE(IRIX_65,,IRIX 6.5)
+  ;;
+esac
+
+dnl ---------------------
+dnl Integrated VTY option
+dnl ---------------------
+case "${enable_vtysh}" in
+  "yes") VTYSH="vtysh";
+         AC_DEFINE(VTYSH,,VTY shell)
+	 AC_PATH_PROG(PERL, perl)
+dnl	 Vtysh uses libreadline, which looks for termcap functions at
+dnl	 configure time.  We follow readlines search order.
+dnl	 The required procedures are in libtermcap on NetBSD, in
+dnl	 [TODO] on Linux, and in [TODO] on Solaris.
+	 AC_CHECK_LIB(termcap, tputs, LIBREADLINE="$LIBREADLINE -ltermcap",
+	   [AC_CHECK_LIB(tinfo, tputs, LIBREADLINE="$LIBREADLINE -ltinfo",
+	     [AC_CHECK_LIB(curses, tputs, LIBREADLINE="$LIBREADLINE -lcurses",
+	       [AC_CHECK_LIB(ncurses, tputs, 
+	                     LIBREADLINE="$LIBREADLINE -lncurses")]
+	      )]
+	    )]
+	  )
+         AC_CHECK_LIB(readline, main, LIBREADLINE="$LIBREADLINE -lreadline",,
+                      "$LIBREADLINE")
+         if test $ac_cv_lib_readline_main = no; then
+           AC_MSG_ERROR([vtysh needs libreadline but was not found and usable on your system.])
+         fi
+	 AC_CHECK_HEADER(readline/history.h)
+	 if test $ac_cv_header_readline_history_h = no;then
+           AC_MSG_ERROR([readline is too old to have readline/history.h, please update to the latest readline library.])
+	 fi
+	 AC_CHECK_LIB(readline, rl_completion_matches, 
+	              LIBREADLINE="$LIBREADLINE",, "$LIBREADLINE")
+         if test $ac_cv_lib_readline_rl_completion_matches = no; then
+           AC_DEFINE(rl_completion_matches,completion_matches,Old readline)
+	 fi
+	 ;;
+  "no" ) VTYSH="";;
+  *    ) ;;
+esac
+AC_SUBST(LIBREADLINE)
+
+dnl ----------
+dnl PAM module
+dnl ----------
+if test "$with_libpam" = "yes"; then
+  AC_CHECK_HEADER([security/pam_misc.h],
+    [AC_DEFINE(HAVE_PAM_MISC_H,,Have pam_misc.h)
+     AC_DEFINE(PAM_CONV_FUNC,misc_conv,Have misc_conv)
+     pam_conv_func="misc_conv"
+    ],
+    [], QUAGGA_INCLUDES)
+  AC_CHECK_HEADER([security/openpam.h],
+    [AC_DEFINE(HAVE_OPENPAM_H,,Have openpam.h)
+     AC_DEFINE(PAM_CONV_FUNC,openpam_ttyconv,Have openpam_ttyconv)
+     pam_conv_func="openpam_ttyconv"
+    ],
+    [], QUAGGA_INCLUDES)
+  if test -z "$ac_cv_header_security_pam_misc_h$ac_cv_header_security_openpam_h" ; then
+    AC_MSG_WARN([*** pam support will not be built ***])
+    with_libpam="no"
+  fi
+fi
+
+if test "$with_libpam" = "yes"; then
+dnl took this test from proftpds configure.in and suited to our needs
+dnl -------------------------------------------------------------------------
+dnl
+dnl This next check looks funky due to a linker problem with some versions
+dnl of the PAM library.  Prior to 0.72 release, the Linux PAM shared library
+dnl omitted requiring libdl linking information. PAM-0.72 or better ships
+dnl with RedHat 6.2 and Debian 2.2 or better.
+AC_CHECK_LIB(pam, pam_start,
+  [AC_CHECK_LIB(pam, $pam_conv_func,
+    [AC_DEFINE(USE_PAM,,Use PAM for authentication)
+     LIBPAM="-lpam"],
+    [AC_DEFINE(USE_PAM,,Use PAM for authentication)
+     LIBPAM="-lpam -lpam_misc"]
+    )
+  ],
+
+  [AC_CHECK_LIB(pam, pam_end,
+    [AC_CHECK_LIB(pam, $pam_conv_func,
+      [AC_DEFINE(USE_PAM,,Use PAM for authentication)
+       LIBPAM="-lpam -ldl"],
+      [AC_DEFINE(USE_PAM,,Use PAM for authentication)
+       LIBPAM="-lpam -ldl -lpam_misc"]
+     )
+  ],AC_MSG_WARN([*** pam support will not be built ***]),
+  [-ldl])
+  ]
+)
+fi
+AC_SUBST(LIBPAM)
+
+dnl -------------------------------
+dnl Endian-ness check
+dnl -------------------------------
+AC_WORDS_BIGENDIAN
+
+dnl -------------------------------
+dnl check the size in byte of the C
+dnl -------------------------------
+dnl AC_CHECK_SIZEOF(char)
+dnl AC_CHECK_SIZEOF(int)
+dnl AC_CHECK_SIZEOF(short)
+dnl AC_CHECK_SIZEOF(long)
+
+dnl ----------------------------
+dnl check existance of functions
+dnl ----------------------------
+AC_FUNC_CHOWN
+AC_FUNC_FNMATCH
+AC_FUNC_FORK
+AC_FUNC_MALLOC
+AC_FUNC_MEMCMP
+AC_FUNC_MKTIME
+AC_FUNC_STRFTIME
+AC_FUNC_REALLOC
+AC_FUNC_STAT
+AC_FUNC_SELECT_ARGTYPES
+AC_FUNC_STRFTIME
+dnl Avoid AC_FUNC_STRNLEN because it pulls in AC_SYSTEM_EXTENSIONS which
+dnl can lead to strange side effects.  So we just check for strnlen
+dnl directly, see below.
+dnl AC_FUNC_STRNLENdnl
+AC_FUNC_VPRINTF
+
+dnl -------------------------------
+dnl bgpd needs pow() and hence libm
+dnl -------------------------------
+TMPLIBS="$LIBS"
+AC_CHECK_HEADER([math.h],
+  [AC_CHECK_LIB([m], [pow],
+    [LIBM="-lm"
+     LIBS="$LIBS $LIBM"
+     AC_DEFINE(HAVE_LIBM,, Have libm)
+     AC_CHECK_FUNCS(pow,[],[LIBM=""])
+    ])
+])
+if test x"$LIBM" = x ; then
+  AC_MSG_WARN([Unable to find working pow function - bgpd may not link])
+fi
+LIBS="$TMPLIBS"
+AC_SUBST(LIBM)
+
+dnl ---------------
+dnl other functions
+dnl ---------------
+AC_CHECK_FUNCS([dup2 ftruncate getcwd gethostbyname getpagesize gettimeofday \
+	inet_ntoa inet_aton strnlen \
+	memchr memmove memset select socket \
+	strcasecmp strchr strcspn strdup strerror \
+	strncasecmp strndup strrchr strspn strstr \
+	strtol strtoul strlcat strlcpy \
+	daemon snprintf vsnprintf \
+	if_nametoindex if_indextoname getifaddrs \
+	uname fcntl])
+
+AC_CHECK_FUNCS(setproctitle, ,
+  [AC_CHECK_LIB(util, setproctitle, 
+     [LIBS="$LIBS -lutil"
+      AC_DEFINE(HAVE_SETPROCTITLE,, Have setproctitle)
+     ]
+   )
+  ]
+)
+
+dnl ------------------------------------
+dnl Determine routing get and set method
+dnl ------------------------------------
+AC_MSG_CHECKING(zebra between kernel interface method)
+if test x"$opsys" = x"gnu-linux"; then
+  if test "${enable_netlink}" = "yes";then
+    AC_MSG_RESULT(netlink)
+    RT_METHOD=rt_netlink.o
+    AC_DEFINE(HAVE_NETLINK,,netlink)
+    netlink=yes
+  elif test "${enable_netlink}" = "no"; then
+    AC_MSG_RESULT(ioctl)
+    RT_METHOD=rt_ioctl.o
+    netlink=no
+  else
+    AC_MSG_RESULT(netlink)
+    RT_METHOD=rt_netlink.o
+    AC_DEFINE(HAVE_NETLINK,,netlink)
+    netlink=yes
+  fi
+elif test x"$opsys" = x"sol2-6";then
+  AC_MSG_RESULT(Route socket)
+  KERNEL_METHOD="kernel_socket.o"
+  RT_METHOD="rt_socket.o"
+elif test x"$opsys" = x"sol8";then
+  AC_MSG_RESULT(Route socket)
+  KERNEL_METHOD="kernel_socket.o"
+  RT_METHOD="rt_socket.o"
+elif test "$opsys" = "irix" ; then
+  AC_MSG_RESULT(Route socket)
+  KERNEL_METHOD="kernel_socket.o"
+  RT_METHOD="rt_socket.o"
+else
+  AC_TRY_RUN([#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+main ()
+{
+  int ac_sock;
+
+  ac_sock = socket (AF_ROUTE, SOCK_RAW, 0);
+  if (ac_sock < 0 && errno == EINVAL)
+    exit (1);
+  exit (0);
+}],
+  [KERNEL_METHOD=kernel_socket.o
+   RT_METHOD=rt_socket.o
+   AC_MSG_RESULT(socket)],
+  [RT_METHOD=rt_ioctl.o
+   AC_MSG_RESULT(ioctl)],
+  [KERNEL_METHOD=kernel_socket.o
+   RT_METHOD=rt_socket.o
+   AC_MSG_RESULT(socket)])
+fi
+AC_SUBST(RT_METHOD)
+AC_SUBST(KERNEL_METHOD)
+AC_SUBST(OTHER_METHOD)
+
+dnl --------------------------
+dnl Determine IS-IS I/O method
+dnl --------------------------
+AC_CHECK_HEADER(net/bpf.h)
+AC_CHECK_HEADER(sys/dlpi.h)
+AC_MSG_CHECKING(zebra IS-IS I/O method)
+if test x"$opsys" = x"gnu-linux"; then
+  AC_MSG_RESULT(pfpacket)
+  ISIS_METHOD=isis_pfpacket.o
+elif test x"$opsys" = x"sol2-6" -o x"$opsys" = x"sol8"; then
+  AC_MSG_RESULT(DLPI)
+  ISIS_METHOD="isis_dlpi.o"
+else
+  if test $ac_cv_header_net_bpf_h = no; then
+    if test $ac_cv_header_sys_dlpi_h = no; then
+      AC_MSG_RESULT(none)
+      AC_MSG_WARN([*** IS-IS support will not be built ***])
+      ISISD=""
+    else
+      AC_MSG_RESULT(DLPI)
+    fi
+    ISIS_METHOD="isis_dlpi.o"
+  else
+    AC_MSG_RESULT(BPF)
+    ISIS_METHOD="isis_bpf.o"
+  fi
+fi
+AC_SUBST(ISIS_METHOD)
+
+dnl ------------------------------------
+dnl check for broken CMSG_FIRSTHDR macro
+dnl ------------------------------------
+AC_MSG_CHECKING(for broken CMSG_FIRSTHDR)
+AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#ifdef SUNOS_5
+#define _XPG4_2
+#define __EXTENSIONS__
+#endif
+#ifdef HAVE_STDLIB_H
+# include <stdlib.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+
+main()
+{
+  struct msghdr msg;
+  char buf[4];
+
+  msg.msg_control = buf;
+  msg.msg_controllen = 0;
+
+  if (CMSG_FIRSTHDR(&msg) != NULL)
+    exit(0);
+  exit (1);
+}]])],[AC_MSG_RESULT(yes - using workaround) AC_DEFINE(HAVE_BROKEN_CMSG_FIRSTHDR,,Broken CMSG_FIRSTHDR)],
+[AC_MSG_RESULT(no)],[AC_MSG_RESULT(no)])
+
+dnl ------------------------------
+dnl check kernel route read method
+dnl ------------------------------
+AC_CACHE_CHECK(route read method check, zebra_rtread,
+[if test "$netlink" = yes; then
+  RTREAD_METHOD="rtread_netlink.o"
+  zebra_rtread="netlink"
+else
+for zebra_rtread in /proc/net/route /dev/ip /dev/null;
+do
+  test x`ls $zebra_rtread 2>/dev/null` = x"$zebra_rtread" && break
+done
+case $zebra_rtread in
+  "/proc/net/route") RTREAD_METHOD="rtread_proc.o"
+                     zebra_rtread="proc";;
+  "/dev/ip")
+                     case "$host" in
+                       *-freebsd*)    RTREAD_METHOD=rtread_sysctl.o
+                                      zebra_rtread="sysctl";;
+                       *)             RTREAD_METHOD="rtread_getmsg.o"
+                                      zebra_rtread="getmsg";;
+                     esac;;
+  *)                 RTREAD_METHOD="rtread_sysctl.o"
+                     zebra_rtread="sysctl";;
+esac
+fi])
+AC_SUBST(RTREAD_METHOD)
+
+dnl -----------------------------
+dnl check interface lookup method
+dnl -----------------------------
+IOCTL_METHOD=ioctl.o
+AC_MSG_CHECKING(interface looking up method)
+if test "$netlink" = yes; then
+  AC_MSG_RESULT(netlink)
+  IF_METHOD=if_netlink.o
+elif test "$opsys" = "sol2-6";then
+  AC_MSG_RESULT(Solaris GIF)
+  IF_METHOD=if_ioctl.o
+elif test "$opsys" = "sol8";then
+  AC_MSG_RESULT(Solaris GLIF)
+  IF_METHOD=if_ioctl_solaris.o
+  IOCTL_METHOD=ioctl_solaris.o
+elif test "$opsys" = "irix" ; then
+  AC_MSG_RESULT(IRIX)
+  IF_METHOD=if_ioctl.o
+elif test "$opsys" = "openbsd";then
+  AC_MSG_RESULT(openbsd)
+  IF_METHOD=if_ioctl.o
+elif grep NET_RT_IFLIST /usr/include/sys/socket.h >/dev/null 2>&1; then
+  AC_MSG_RESULT(sysctl)
+    IF_METHOD=if_sysctl.o
+    AC_DEFINE(HAVE_NET_RT_IFLIST,,NET_RT_IFLIST)
+else
+    AC_MSG_RESULT(ioctl)
+    IF_METHOD=if_ioctl.o
+fi
+AC_SUBST(IF_METHOD)
+AC_SUBST(IOCTL_METHOD)
+
+dnl ---------------------------------------------------------------
+dnl figure out how to specify an interface in multicast sockets API
+dnl ---------------------------------------------------------------
+AC_CHECK_MEMBERS([struct ip_mreqn.imr_ifindex], [], [], QUAGGA_INCLUDES)
+
+AC_MSG_CHECKING([for BSD struct ip_mreq hack])
+AC_TRY_COMPILE([#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif],[#if (defined(__FreeBSD__) && (__FreeBSD_version >= 500022 || (__FreeBSD_version < 500000 && __FreeBSD_version >= 440000))) || (defined(__NetBSD__) && defined(__NetBSD_Version__) && __NetBSD_Version__ >= 106010000)
+  return (0);
+#else
+  #error No support for BSD struct ip_mreq hack detected
+#endif],[AC_MSG_RESULT(yes)
+AC_DEFINE(HAVE_BSD_STRUCT_IP_MREQ_HACK,,[Can pass ifindex in struct ip_mreq])],
+AC_MSG_RESULT(no))
+
+dnl -----------------------
+dnl check proc file system.
+dnl -----------------------
+if test -r /proc/net/dev; then
+  AC_DEFINE(HAVE_PROC_NET_DEV,,/proc/net/dev)
+  IF_PROC=if_proc.o
+fi
+
+if test -r /proc/net/if_inet6; then
+  AC_DEFINE(HAVE_PROC_NET_IF_INET6,,/proc/net/if_inet6)
+  IF_PROC=if_proc.o
+fi
+AC_SUBST(IF_PROC)
+
+dnl -----------------------------
+dnl check ipforward detect method
+dnl -----------------------------
+AC_CACHE_CHECK(ipforward method check, zebra_ipforward_path,
+[for zebra_ipforward_path in /proc/net/snmp /dev/ip /dev/null;
+do
+  test x`ls $zebra_ipforward_path 2>/dev/null` = x"$zebra_ipforward_path" && break
+done
+case $zebra_ipforward_path in
+  "/proc/net/snmp")  IPFORWARD=ipforward_proc.o
+                     zebra_ipforward_path="proc";;
+  "/dev/ip")         
+                     case "$host" in
+                       *-nec-sysv4*)  IPFORWARD=ipforward_ews.o
+                                      zebra_ipforward_path="ews";;
+                       *-freebsd*)    IPFORWARD=ipforward_sysctl.o
+                                      zebra_ipforward_path="sysctl";;
+                       *)             IPFORWARD=ipforward_solaris.o
+                                      zebra_ipforward_path="solaris";;
+                     esac;;
+  *)                 IPFORWARD=ipforward_sysctl.o
+                     zebra_ipforward_path="sysctl";;
+esac])
+AC_SUBST(IPFORWARD)
+
+AC_CHECK_FUNCS(getaddrinfo, [have_getaddrinfo=yes], [have_getaddrinfo=no])
+
+dnl ----------
+dnl IPv6 check
+dnl ----------
+AC_MSG_CHECKING(whether does this OS have IPv6 stack)
+if test "${enable_ipv6}" = "no"; then
+  AC_MSG_RESULT(disabled)
+else
+dnl ----------
+dnl INRIA IPv6
+dnl ----------
+  if grep IPV6_INRIA_VERSION /usr/include/netinet/in.h >/dev/null 2>&1; then
+    zebra_cv_ipv6=yes
+    AC_DEFINE(HAVE_IPV6,1,INRIA IPv6)
+    AC_DEFINE(INRIA_IPV6,1,INRIA IPv6)
+    RIPNGD="ripngd"
+    OSPF6D="ospf6d"
+    LIB_IPV6=""
+    AC_MSG_RESULT(INRIA IPv6)
+dnl ---------
+dnl KAME IPv6
+dnl ---------
+  elif grep WIDE /usr/include/netinet6/in6.h >/dev/null 2>&1; then
+    zebra_cv_ipv6=yes
+    AC_DEFINE(HAVE_IPV6,1,KAME IPv6)
+    AC_DEFINE(KAME,1,KAME IPv6)
+    RIPNGD="ripngd"
+    OSPF6D="ospf6d"
+    if test -d /usr/local/v6/lib -a -f /usr/local/v6/lib/libinet6.a; then
+      LIB_IPV6="-L/usr/local/v6/lib -linet6"
+    fi
+    AC_MSG_RESULT(KAME)
+dnl -------------------------
+dnl MUSICA IPv6
+dnl  default host check
+dnl  It is not used by Kheops
+dnl -------------------------
+  elif grep MUSICA /usr/include6/netinet6/in6.h >/dev/null 2>&1; then
+    zebra_cv_ipv6=yes
+    AC_DEFINE(HAVE_IPV6,1,Musicia IPv6)
+    AC_DEFINE(MUSICA,1,Musica IPv6 stack)
+    AC_DEFINE(KAME,1,KAME IPv6 stack)
+    RIPNGD="ripngd"
+    OSPF6D="ospf6d"
+    if test -d /usr/local/v6/lib -a -f /usr/local/v6/lib/libinet6.a; then
+      LIB_IPV6="-L/usr/local/v6/lib -linet6"
+    fi
+    AC_MSG_RESULT(MUSICA)
+dnl ---------
+dnl NRL check
+dnl ---------
+  elif grep NRL /usr/include/netinet6/in6.h >/dev/null 2>&1; then
+    zebra_cv_ipv6=yes
+    AC_DEFINE(HAVE_IPV6,1,NRL IPv6)
+    AC_DEFINE(NRL,1,NRL)
+    RIPNGD="ripngd"
+    OSPF6D="ospf6d"
+    if test x"$opsys" = x"bsdi";then
+      AC_DEFINE(BSDI_NRL,,BSDI)
+      AC_MSG_RESULT(BSDI_NRL)
+    else
+      AC_MSG_RESULT(NRL)
+    fi
+dnl ------------------------------------
+dnl Solaris 9, 10 and potentially higher
+dnl ------------------------------------
+  elif test x"$opsys" = x"sol8"; then
+    zebra_cv_ipv6=yes;
+    AC_DEFINE(HAVE_IPV6, 1, IPv6)
+    AC_DEFINE(SOLARIS_IPV6, 1, Solaris IPv6)
+    RIPNGD="ripngd"
+    OSPF6D="ospf6d"
+    AC_MSG_RESULT(Solaris IPv6)
+dnl ----------
+dnl Linux IPv6
+dnl ----------
+  elif test "${enable_ipv6}" = "yes"; then
+    AC_EGREP_CPP(yes, [
+      #include <linux/version.h>
+      /* 2.1.128 or later */
+      #if LINUX_VERSION_CODE >= 0x020180
+      yes
+      #endif],
+      [zebra_cv_ipv6=yes
+       zebra_cv_linux_ipv6=yes
+       AC_MSG_RESULT(Linux IPv6)])
+  else
+    if test x`ls /proc/net/ipv6_route 2>/dev/null` = x"/proc/net/ipv6_route"
+     then
+      zebra_cv_ipv6=yes
+      zebra_cv_linux_ipv6=yes
+      AC_MSG_RESULT(Linux IPv6)
+    fi
+  fi
+
+  if test "$zebra_cv_linux_ipv6" = "yes";then
+    AC_MSG_CHECKING(whether libc has IPv6 support)
+    AC_TRY_LINK([#include <netinet/in.h>
+    ],[ int a; a = (int) in6addr_any.s6_addr[0]; if (a != 12345) return a; ],
+    [AC_MSG_RESULT(yes)
+      zebra_cv_ipv6=yes
+      zebra_cv_linux_ipv6=yes],
+    [AC_MSG_RESULT(no)
+      zebra_cv_ipv6=no
+      zebra_cv_linux_ipv6=no])
+  fi
+
+  if test "$zebra_cv_linux_ipv6" = "yes";then
+    AC_MSG_CHECKING(for GNU libc >= 2.1)
+    AC_DEFINE(HAVE_IPV6,1,Linux IPv6)
+    AC_EGREP_CPP(yes, [
+#include <features.h>
+#if __GLIBC__ >= 2 && __GLIBC_MINOR__ >= 1
+  yes
+#endif], 
+      [glibc=yes
+       AC_DEFINE(LINUX_IPV6,1,Linux IPv6 stack)
+       AC_MSG_RESULT(yes)], 
+      AC_MSG_RESULT(no)
+    )
+    RIPNGD="ripngd"
+    OSPF6D="ospf6d"
+    if test "$glibc" != "yes"; then
+      INCLUDES="-I/usr/inet6/include"
+      if test x`ls /usr/inet6/lib/libinet6.a 2>/dev/null` != x;then
+         LIB_IPV6="-L/usr/inet6/lib -linet6"
+      fi
+    fi
+  fi
+
+dnl -----------------------
+dnl Set IPv6 related values
+dnl -----------------------
+  LIBS="$LIB_IPV6 $LIBS"
+  AC_SUBST(LIB_IPV6)
+
+  if test x"$RIPNGD" = x""; then
+    AC_MSG_RESULT(IPv4 only)
+  fi
+fi
+
+dnl ------------------
+dnl IPv6 header checks
+dnl ------------------
+if test "x${zebra_cv_ipv6}" = "xyes"; then
+AC_CHECK_HEADERS([netinet6/in6.h netinet/in6_var.h netinet/icmp6.h \
+	netinet6/in6_var.h netinet6/nd6.h], [], [],
+	QUAGGA_INCLUDES)
+fi
+
+m4_define([QUAGGA_INCLUDES],dnl
+QUAGGA_INCLUDES
+[#if HAVE_NETINET6_IN6_H
+#include <netinet6/in6.h>
+#endif
+#if HAVE_NETINET_IN6_VAR_H
+#include <netinet/in6_var.h>
+#endif
+#if HAVE_NETINET_ICMP6_H
+# include <netinet/icmp6.h>
+#endif
+#if HAVE_NETINET6_IN6_VAR_H
+# include <netinet6/in6_var.h>
+#endif
+#if HAVE_NETINET6_ND6_H
+# include <netinet6/nd6.h>
+#endif
+])dnl
+
+dnl --------------------
+dnl Daemon disable check
+dnl --------------------
+if test "${enable_zebra}" = "no";then
+  ZEBRA=""
+else
+  ZEBRA="zebra"
+fi
+
+if test "${enable_bgpd}" = "no";then
+  BGPD=""
+else
+  BGPD="bgpd"
+fi
+
+if test "${enable_ripd}" = "no";then
+  RIPD=""
+else
+  RIPD="ripd"
+fi
+
+if test "${enable_ospfd}" = "no";then
+  OSPFD=""
+else
+  OSPFD="ospfd"
+fi
+
+if test "${enable_watchquagga}" = "no";then
+  WATCHQUAGGA=""
+else
+  WATCHQUAGGA="watchquagga"
+fi
+
+OSPFCLIENT=""
+if test "${enable_opaque_lsa}" = "yes"; then
+  if test "${enable_ospfapi}" != "no";then
+    AC_DEFINE(SUPPORT_OSPF_API,,OSPFAPI)
+
+    if test "${enable_ospfclient}" != "no";then
+      OSPFCLIENT="ospfclient"
+    fi
+  fi
+
+fi
+
+case "${enable_ripngd}" in
+  "yes") RIPNGD="ripngd";;
+  "no" ) RIPNGD="";;
+  *    ) ;;
+esac
+
+case "${enable_ospf6d}" in
+  "yes") OSPF6D="ospf6d";;
+  "no" ) OSPF6D="";;
+  *    ) ;;
+esac
+
+case "${enable_isisd}" in
+  "yes") ISISD="isisd";;
+  "no" ) ISISD="";;
+  *    ) ;;
+esac
+
+# XXX Perhaps auto-enable on Solaris, but that's messy for cross builds.
+case "${enable_solaris}" in
+  "yes") SOLARIS="solaris";;
+  "no" ) SOLARIS="";;
+  *    ) ;;
+esac
+
+if test "${enable_bgp_announce}" = "no";then
+  AC_DEFINE(DISABLE_BGP_ANNOUNCE,,Disable BGP installation to zebra)
+fi
+
+AC_SUBST(ZEBRA)
+AC_SUBST(BGPD)
+AC_SUBST(RIPD)
+AC_SUBST(RIPNGD)
+AC_SUBST(OSPFD)
+AC_SUBST(OSPF6D)
+AC_SUBST(WATCHQUAGGA)
+AC_SUBST(ISISD)
+AC_SUBST(SOLARIS)
+AC_SUBST(VTYSH)
+AC_SUBST(INCLUDES)
+AC_SUBST(CURSES)
+AC_SUBST(OSPFCLIENT)
+AC_SUBST(OSPFAPI)
+AC_CHECK_LIB(c, inet_ntop, [AC_DEFINE(HAVE_INET_NTOP,,inet_ntop)])
+AC_CHECK_LIB(c, inet_pton, [AC_DEFINE(HAVE_INET_PTON,,inet_pton)])
+AC_CHECK_LIB(crypt, crypt)
+AC_CHECK_LIB(resolv, res_init)
+
+dnl ---------------------------------------------------
+dnl BSD/OS 4.1 define inet_XtoY function as __inet_XtoY
+dnl ---------------------------------------------------
+AC_CHECK_FUNC(__inet_ntop, AC_DEFINE(HAVE_INET_NTOP,,__inet_ntop))
+AC_CHECK_FUNC(__inet_pton, AC_DEFINE(HAVE_INET_PTON,,__inet_pton))
+AC_CHECK_FUNC(__inet_aton, AC_DEFINE(HAVE_INET_ATON,,__inet_aton))
+
+dnl ---------------------------
+dnl check system has GNU regexp
+dnl ---------------------------
+dnl AC_MSG_CHECKING(whether system has GNU regex)
+AC_CHECK_LIB(c, regexec,
+[AC_DEFINE(HAVE_GNU_REGEX,,GNU regexp library)
+ LIB_REGEX=""],
+[LIB_REGEX="regex.o"])
+AC_SUBST(LIB_REGEX)
+
+dnl ------------------
+dnl check Net-SNMP library
+dnl ------------------
+if test "${enable_snmp}" = "yes"; then
+    LIBS="${LIBS} -lcrypto"
+    AC_CHECK_LIB(netsnmp, asn_parse_int,
+    	[AC_DEFINE(HAVE_NETSNMP,,Net SNMP) 
+    	 AC_DEFINE(HAVE_SNMP,,SNMP)
+    	 LIBS="${LIBS} -lnetsnmp"],
+    	[AC_MSG_ERROR([--enable-snmp given, but cannot find support for SNMP])])
+    
+    for ac_snmp in /usr/include \
+    		/usr/local/include \
+    		/dev/null; do
+    	test -f "${ac_snmp}/net-snmp/library/asn1.h" && break
+    done
+    
+    case ${ac_snmp} in
+    	/dev/null)
+    		AC_MSG_ERROR([--enable-snmp given, but can not find header])
+    		;;
+    	*)
+    		SNMP_INCLUDES="-I${ac_snmp}/net-snmp"
+    		SNMP_INCLUDES="${SNMP_INCLUDES} -I${ac_snmp}/net-snmp/library"
+    		;;
+    esac
+    
+    AC_SUBST(SNMP_INCLUDES)
+fi
+
+dnl ---------------------------
+dnl sockaddr and netinet checks
+dnl ---------------------------
+AC_CHECK_TYPES([struct sockaddr, struct sockaddr_in,
+	struct sockaddr_in6, struct sockaddr_un, struct sockaddr_dl,
+	socklen_t,
+	struct ifaliasreq, struct if6_aliasreq, struct in6_aliasreq,
+	struct nd_opt_adv_interval, struct rt_addrinfo,
+	struct nd_opt_homeagent_info, struct nd_opt_adv_interval],
+	[], [], QUAGGA_INCLUDES)
+
+AC_CHECK_MEMBERS([struct sockaddr.sa_len,
+	struct sockaddr_in.sin_len, struct sockaddr_un.sun_len,
+	struct sockaddr_in6.sin6_scope_id,
+	struct if6_aliasreq.ifra_lifetime,
+	struct nd_opt_adv_interval.nd_opt_ai_type],
+	[], [], QUAGGA_INCLUDES)
+
+dnl ---------------------------
+dnl IRDP/pktinfo/icmphdr checks
+dnl ---------------------------
+AC_CHECK_TYPES([struct in_pktinfo], 
+ [AC_CHECK_TYPES([struct icmphdr],
+   [if test "${enable_irdp}" != "no"; then
+      AC_DEFINE(HAVE_IRDP,, IRDP)
+    fi],
+   [if test "${enable_irdp}" = "yes"; then
+      AC_MSG_ERROR(['IRDP requires in_pktinfo at the moment!'])
+    fi], [QUAGGA_INCLUDES])],
+ [if test "${enable_irdp}" = "yes"; then
+    AC_MSG_ERROR(['IRDP requires in_pktinfo at the moment!'])
+  fi], [QUAGGA_INCLUDES])
+
+dnl --------------------------------------
+dnl checking for getrusage struct and call
+dnl --------------------------------------
+AC_MSG_CHECKING(whether getrusage is available)
+AC_TRY_COMPILE([#include <sys/resource.h>
+],[struct rusage ac_x; getrusage (RUSAGE_SELF, &ac_x);],
+[AC_MSG_RESULT(yes)
+ AC_DEFINE(HAVE_RUSAGE,,rusage)],
+ AC_MSG_RESULT(no))
+
+dnl -------------------
+dnl capabilities checks
+dnl -------------------
+if test "${enable_capabilities}" != "no"; then
+  AC_MSG_CHECKING(whether prctl PR_SET_KEEPCAPS is available)
+  AC_TRY_COMPILE([#include <sys/prctl.h>],[prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0);],
+    [AC_MSG_RESULT(yes)
+     AC_DEFINE(HAVE_PR_SET_KEEPCAPS,,prctl)
+     quagga_ac_keepcaps="yes"],
+     AC_MSG_RESULT(no)
+  )
+  if test x"${quagga_ac_keepcaps}" = x"yes"; then
+    AC_CHECK_HEADERS(sys/capability.h)
+  fi
+  if test x"${ac_cv_header_sys_capability_h}" = x"yes"; then
+    AC_CHECK_LIB(cap, cap_init, 
+      [AC_DEFINE(HAVE_LCAPS,1,Capabilities)
+       LIBCAP="-lcap"
+       quagga_ac_lcaps="yes"]
+    )
+  else
+    AC_CHECK_HEADERS(priv.h,
+     [AC_MSG_CHECKING(Solaris style privileges are available)
+      AC_TRY_COMPILE([#include <priv.h>],[getpflags(PRIV_AWARE);],
+    	  [AC_MSG_RESULT(yes)
+    	   AC_DEFINE(HAVE_SOLARIS_CAPABILITIES,1,getpflags)
+    	   quagga_ac_scaps="yes"],
+    	   AC_MSG_RESULT(no)
+      )
+     ]
+   )
+  fi
+  if test x"${quagga_ac_scaps}" = x"yes" \
+       -o x"${quagga_ac_lcaps}" = x"yes"; then
+    AC_DEFINE(HAVE_CAPABILITIES,1,capabilities)
+  fi
+fi
+AC_SUBST(LIBCAP)
+
+dnl ---------------------------
+dnl check for glibc 'backtrace'
+dnl --------------------------- 
+if test "${glibc}" = "yes"; then
+   AC_CHECK_HEADER([execinfo.h],
+    [AC_CHECK_FUNC([backtrace],
+    	[AC_DEFINE(HAVE_GLIBC_BACKTRACE,,[Glibc backtrace])
+    	 AC_DEFINE(HAVE_STACK_TRACE,,[Stack symbol decoding])
+    	])
+    ])
+fi
+
+dnl -----------------------------------------
+dnl check for malloc mallinfo struct and call
+dnl this must try and link using LIBS, in
+dnl order to check no alternative allocator
+dnl has been specified, which might not provide
+dnl mallinfo, e.g. such as Umem on Solaris.
+dnl -----------------------------------------
+AC_CHECK_HEADER([malloc.h],
+ [AC_MSG_CHECKING(whether mallinfo is available)
+  AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <malloc.h>]],
+                        [[struct mallinfo ac_x; ac_x = mallinfo ();]])],
+      [AC_MSG_RESULT(yes)
+       AC_DEFINE(HAVE_MALLINFO,,mallinfo)],
+       AC_MSG_RESULT(no)
+  )
+ ], [], QUAGGA_INCLUDES)
+
+dnl ----------
+dnl configure date
+dnl ----------
+CONFDATE=`date '+%Y%m%d'`
+AC_SUBST(CONFDATE)
+
+dnl ------------------------------
+dnl set paths for state directory
+dnl ------------------------------
+if test "${prefix}" = "NONE"; then
+  quagga_statedir_prefix="";
+else
+  quagga_statedir_prefix=${prefix}
+fi
+if test "${localstatedir}" = '${prefix}/var'; then
+  AC_CACHE_CHECK(state directory,ac_statedir,
+  [for QUAGGA_STATE_DIR in ${quagga_statedir_prefix}/var/run dnl
+			${quagga_statedir_prefix}/var/adm dnl
+			${quagga_statedir_prefix}/etc dnl
+			/var/run	dnl
+                        /var/adm	dnl
+                        /etc		dnl
+                        /dev/null;
+  do
+    test -d $QUAGGA_STATE_DIR && break
+  done
+  quagga_statedir=$QUAGGA_STATE_DIR])
+else
+  quagga_statedir=${localstatedir}
+  AC_MSG_CHECKING(directory to use for state file)
+  AC_MSG_RESULT(${quagga_statedir})
+  AC_SUBST(quagga_statedir)
+fi
+if test $quagga_statedir = "/dev/null"; then
+    AC_MSG_ERROR('STATE DIRECTORY NOT FOUND! FIX OR SPECIFY --localstatedir!')
+fi
+
+AC_DEFINE_UNQUOTED(PATH_ZEBRA_PID, "$quagga_statedir/zebra.pid",zebra PID)
+AC_DEFINE_UNQUOTED(PATH_RIPD_PID, "$quagga_statedir/ripd.pid",ripd PID)
+AC_DEFINE_UNQUOTED(PATH_RIPNGD_PID, "$quagga_statedir/ripngd.pid",ripngd PID)
+AC_DEFINE_UNQUOTED(PATH_BGPD_PID, "$quagga_statedir/bgpd.pid",bgpd PID)
+AC_DEFINE_UNQUOTED(PATH_OSPFD_PID, "$quagga_statedir/ospfd.pid",ospfd PID)
+AC_DEFINE_UNQUOTED(PATH_OSPF6D_PID, "$quagga_statedir/ospf6d.pid",ospf6d PID)
+AC_DEFINE_UNQUOTED(PATH_ISISD_PID, "$quagga_statedir/isisd.pid",isisd PID)
+AC_DEFINE_UNQUOTED(PATH_WATCHQUAGGA_PID, "$quagga_statedir/watchquagga.pid",watchquagga PID)
+AC_DEFINE_UNQUOTED(ZEBRA_SERV_PATH, "$quagga_statedir/zserv.api",zebra api socket)
+AC_DEFINE_UNQUOTED(ZEBRA_VTYSH_PATH, "$quagga_statedir/zebra.vty",zebra vty socket)
+AC_DEFINE_UNQUOTED(RIP_VTYSH_PATH, "$quagga_statedir/ripd.vty",rip vty socket)
+AC_DEFINE_UNQUOTED(RIPNG_VTYSH_PATH, "$quagga_statedir/ripngd.vty",ripng vty socket)
+AC_DEFINE_UNQUOTED(BGP_VTYSH_PATH, "$quagga_statedir/bgpd.vty",bgpd vty socket)
+AC_DEFINE_UNQUOTED(OSPF_VTYSH_PATH, "$quagga_statedir/ospfd.vty",ospfd vty socket)
+AC_DEFINE_UNQUOTED(OSPF6_VTYSH_PATH, "$quagga_statedir/ospf6d.vty",ospf6d vty socket)
+AC_DEFINE_UNQUOTED(ISIS_VTYSH_PATH, "$quagga_statedir/isisd.vty",isisd vty socket)
+AC_DEFINE_UNQUOTED(DAEMON_VTY_DIR, "$quagga_statedir",daemon vty directory)
+
+dnl -------------------------------
+dnl Quagga sources should always be 
+dnl current wrt interfaces. Dont
+dnl allow deprecated interfaces to
+dnl be exposed.
+dnl -------------------------------
+AC_DEFINE(QUAGGA_NO_DEPRECATED_INTERFACES, 1, Hide deprecated interfaces)
+
+dnl ---------------------------
+dnl Check htonl works correctly
+dnl ---------------------------
+AC_MSG_CHECKING(for working htonl)
+AC_CACHE_VAL(ac_cv_htonl_works,
+ [AC_LINK_IFELSE([AC_LANG_PROGRAM([QUAGGA_INCLUDES],[htonl (0);])],
+ 		[ac_cv_htonl_works=yes], [ac_cv_htonl_works=no])
+ ]
+)
+AC_MSG_RESULT($ac_cv_htonl_works)
+
+AC_CONFIG_FILES([Makefile lib/Makefile zebra/Makefile ripd/Makefile 
+	  ripngd/Makefile bgpd/Makefile ospfd/Makefile watchquagga/Makefile
+	  ospf6d/Makefile isisd/Makefile vtysh/Makefile doc/Makefile 
+	  ospfclient/Makefile tests/Makefile m4/Makefile redhat/Makefile
+	  pkgsrc/Makefile
+	  redhat/quagga.spec 
+	  lib/version.h
+	  doc/defines.texi
+	  isisd/topology/Makefile
+	  pkgsrc/bgpd.sh pkgsrc/ospf6d.sh pkgsrc/ospfd.sh
+	  pkgsrc/ripd.sh pkgsrc/ripngd.sh pkgsrc/zebra.sh])
+AC_CONFIG_FILES([solaris/Makefile])
+
+AC_CONFIG_FILES([vtysh/extract.pl],[chmod +x vtysh/extract.pl])
+## Hack, but working solution to avoid rebuilding of quagga.info.
+## It's already in CVS until texinfo 4.7 is more common.
+AC_OUTPUT
+
+echo "
+Quagga configuration
+--------------------
+quagga version          : ${PACKAGE_VERSION}
+host operationg system  : ${host_os}
+source code location    : ${srcdir}
+compiler                : ${CC}
+compiler flags          : ${CFLAGS}
+make                    : ${MAKE-make}
+includes                : ${INCLUDES} ${SNMP_INCLUDES}
+linker flags            : ${LDFLAGS} ${LIBS} ${LIBCAP} ${LIBREADLINE} ${LIBM}
+state file directory    : ${quagga_statedir}
+config file directory   : `eval echo \`echo ${sysconfdir}\``
+example directory       : `eval echo \`echo ${exampledir}\``
+user to run as		: ${enable_user}
+group to run as		: ${enable_group}
+group for vty sockets	: ${enable_vty_group}
+config file mask        : ${enable_configfile_mask}
+log file mask           : ${enable_logfile_mask}
+
+The above user and group must have read/write access to the state file
+directory and to the config files in the config file directory."
+
+if test x"$quagga_cv_gnu_make" = x"no"; then echo "
+Warning: The ${MAKE-make} programme detected, either in your path or
+via the MAKE variable, is not GNU Make. GNU make may be installed as
+gmake on some systems. and is required to complete a build of Quagga
+" > /dev/stderr 
+fi
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/bfd.c quagga-0.99.9-bfd-0.90.1/lib/bfd.c
--- quagga-0.99.9/lib/bfd.c	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/lib/bfd.c	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,50 @@
+/*
+ * LIB - bfd.c
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include "zebra.h"
+#include "memory.h"
+#include "linklist.h"
+#include "prefix.h"
+#include "table.h"
+#include "bfd.h"
+
+/* Allocate memory for candidate bfd neighbor structure */
+struct bfd_cneigh *
+bfd_cneigh_new ()
+{
+  return XCALLOC (MTYPE_BFD_CNEIGH, sizeof (struct bfd_cneigh));
+}
+
+/* Free memory for candidate bfd neighbor structure */
+void
+bfd_cneigh_free (struct bfd_cneigh *cneighp)
+{
+  if (cneighp->clients)
+    {
+      if (listcount (cneighp->clients))
+	abort ();		/* We cannot free neighbor with non-empy client list */
+      else
+	/* Client list empty so let's remove it */
+	list_free (cneighp->clients);
+    }
+  /* Remove candidate */
+  XFREE (MTYPE_BFD_CNEIGH, cneighp);
+}
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/bfd.h quagga-0.99.9-bfd-0.90.1/lib/bfd.h
--- quagga-0.99.9/lib/bfd.h	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/lib/bfd.h	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ * LIB - bfd.h   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef _QUAGGA_BFD_H
+#define _QUAGGA_BFD_H
+
+#include "zebra.h"
+#include "zebra/zserv.h"
+
+/* Mulihop mode */
+#define BFD_CNEIGH_FLAGS_MULTIHOP (1<< 0)
+/* Passive mode - this flag can be set for candidate neighbor by a client 
+   or as a result of setting interface to passive (logical OR) */
+#define BFD_CNEIGH_FLAGS_PASSIVE  (1<< 1)
+/* not supported */
+#define BFD_CNEIGH_FLAGS_ECHO	  (1<< 2)
+/* not supported */
+#define BFD_CNEIGH_FLAGS_DEMAND   (1<< 3)
+
+#define bfd_flag_1hop_check(X) ((X->flags & BFD_CNEIGH_FLAGS_MULTIHOP) ? 0 : 1)
+#define bfd_flag_mhop_check(X) ((X->flags & BFD_CNEIGH_FLAGS_MULTIHOP) ? 1 : 0)
+#define bfd_flag_passive_check(X) ((X->flags & BFD_CNEIGH_FLAGS_PASSIVE) ? 1 : 0)
+#define bfd_flag_echo_check(X) ((X->flags & BFD_CNEIGH_FLAGS_ECHO) ? 1 : 0)
+#define bfd_flag_demand_check(X) ((X->flags & BFD_CNEIGH_FLAGS_DEMAND) ? 1 : 0)
+
+#define bfd_check_cneigh_family(CNEIGHP) PREFIX_FAMILY(&((CNEIGHP)->raddr))
+
+/* Candidate neighbor structure */
+struct bfd_cneigh
+{
+  struct prefix raddr;		/* Candiate neighbor address */
+  struct prefix laddr;		/* Suggested address when multihop 
+				   is desired */
+  unsigned int ifindex;		/* Suggested interface when single 
+				   hop desired */
+  uint32_t flags;		/* Flags */
+  struct list *clients;		/* Registered clients, 
+				   that wants to track session */
+};
+
+/* Memory managment */
+struct bfd_cneigh *bfd_cneigh_new (void);
+void bfd_cneigh_free (struct bfd_cneigh *cneigh);
+
+#endif /* QUAGGA_BFD_H */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/command.h quagga-0.99.9-bfd-0.90.1/lib/command.h
--- quagga-0.99.9/lib/command.h	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/command.h	2007-10-21 01:09:15.000000000 +0200
@@ -277,6 +277,7 @@ struct desc
 #define CLEAR_STR "Reset functions\n"
 #define RIP_STR "RIP information\n"
 #define BGP_STR "BGP information\n"
+#define BFD_STR "BFD information\n"
 #define OSPF_STR "OSPF information\n"
 #define NEIGHBOR_STR "Specify neighbor router\n"
 #define DEBUG_STR "Debugging functions (see also 'undebug')\n"
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/if.c quagga-0.99.9-bfd-0.90.1/lib/if.c
--- quagga-0.99.9/lib/if.c	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/if.c	2007-10-21 01:09:15.000000000 +0200
@@ -266,6 +266,22 @@ if_lookup_exact_address (struct in_addr 
   return NULL;
 }
 
+struct interface *
+if_lookup_by_sockunion_exact(union sockunion *su)
+{
+  switch(sockunion_family(su))
+  {
+    case AF_INET:
+      return if_lookup_exact_address(su->sin.sin_addr);
+#ifdef HAVE_IPV6
+    case AF_INET6:
+      return if_lookup_exact_address6(&su->sin6.sin6_addr);
+#endif /* HAVE IPV6 */
+    default:
+      abort();
+  }
+}
+
 /* Lookup interface by IPv4 address. */
 struct interface *
 if_lookup_address (struct in_addr src)
@@ -300,6 +316,61 @@ if_lookup_address (struct in_addr src)
   return match;
 }
 
+/* Lookup interface by prefix */
+struct interface *
+if_lookup_prefix (struct prefix *p)
+{
+  struct listnode *node;
+  int bestlen = 0;
+  struct listnode *cnode;
+  struct interface *ifp;
+  struct connected *c;
+  struct interface *match;
+
+  match = NULL;
+
+  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))
+    {
+      for (ALL_LIST_ELEMENTS_RO (ifp->connected, cnode, c))
+	{
+	  if (c->address && (c->address->family == PREFIX_FAMILY(p)) &&
+	      prefix_match(CONNECTED_PREFIX(c), p) &&
+	      (c->address->prefixlen > bestlen))
+	    {
+	      bestlen = c->address->prefixlen;
+	      match = ifp;
+	    }
+	}
+    }
+  return match;
+}
+
+
+#ifdef HAVE_IPV6
+struct interface *
+if_lookup_exact_address6 (struct in6_addr *addr)
+{   
+  struct listnode *ifnode;
+  struct listnode *cnode;
+  struct interface *ifp;
+  struct connected *connected;
+  struct prefix *cp; 
+
+  for (ALL_LIST_ELEMENTS_RO (iflist, ifnode, ifp)) 
+    {
+      for (ALL_LIST_ELEMENTS_RO (ifp->connected, cnode, connected))
+        {
+          cp = connected->address;
+            
+          if (cp->family == AF_INET6)
+            if (IPV6_ADDR_SAME (&cp->u.prefix6, addr))
+              return ifp;
+        }
+    }
+  return NULL;       
+}
+#endif /* HAVE IPV6 */
+
 /* Get interface by name if given name interface doesn't exist create
    one. */
 struct interface *
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/if.h quagga-0.99.9-bfd-0.90.1/lib/if.h
--- quagga-0.99.9/lib/if.h	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/if.h	2007-10-21 01:09:15.000000000 +0200
@@ -22,6 +22,7 @@ Boston, MA 02111-1307, USA.  */
 #define _ZEBRA_IF_H
 
 #include "linklist.h"
+#include "sockunion.h"
 
 /*
   Interface name length.
@@ -234,6 +235,11 @@ extern struct interface *if_create (cons
 extern struct interface *if_lookup_by_index (unsigned int);
 extern struct interface *if_lookup_exact_address (struct in_addr);
 extern struct interface *if_lookup_address (struct in_addr);
+extern struct interface *if_lookup_by_sockunion_exact(union sockunion *su);
+extern struct interface *if_lookup_prefix (struct prefix *p);
+#ifdef HAVE_IPV6
+extern struct interface *if_lookup_exact_address6 (struct in6_addr *addr);
+#endif /* HAVE IPV6 */
 
 /* These 2 functions are to be used when the ifname argument is terminated
    by a '\0' character: */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/log.c quagga-0.99.9-bfd-0.90.1/lib/log.c
--- quagga-0.99.9/lib/log.c	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/log.c	2007-10-21 01:09:15.000000000 +0200
@@ -42,6 +42,7 @@ const char *zlog_proto_names[] = 
   "ZEBRA",
   "RIP",
   "BGP",
+  "BFD",
   "OSPF",
   "RIPNG",
   "OSPF6",
@@ -834,6 +835,11 @@ static const struct zebra_desc_table com
   DESC_ENTRY	(ZEBRA_ROUTER_ID_ADD),
   DESC_ENTRY	(ZEBRA_ROUTER_ID_DELETE),
   DESC_ENTRY	(ZEBRA_ROUTER_ID_UPDATE),
+  DESC_ENTRY	(ZEBRA_IPV4_BFD_CNEIGH_LIST),
+  DESC_ENTRY	(ZEBRA_IPV4_BFD_CNEIGH_ADD),
+  DESC_ENTRY	(ZEBRA_IPV4_BFD_CNEIGH_DEL),
+  DESC_ENTRY	(ZEBRA_IPV4_BFD_NEIGH_UP),
+  DESC_ENTRY	(ZEBRA_IPV4_BFD_NEIGH_DOWN),
 };
 #undef DESC_ENTRY
 
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/log.h quagga-0.99.9-bfd-0.90.1/lib/log.h
--- quagga-0.99.9/lib/log.h	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/log.h	2007-10-21 01:09:15.000000000 +0200
@@ -50,6 +50,7 @@ typedef enum 
   ZLOG_ZEBRA,
   ZLOG_RIP,
   ZLOG_BGP,
+  ZLOG_BFD,
   ZLOG_OSPF,
   ZLOG_RIPNG,  
   ZLOG_OSPF6,
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/Makefile.am quagga-0.99.9-bfd-0.90.1/lib/Makefile.am
--- quagga-0.99.9/lib/Makefile.am	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/Makefile.am	2007-10-21 01:09:15.000000000 +0200
@@ -12,7 +12,7 @@ libzebra_la_SOURCES = \
 	sockunion.c prefix.c thread.c if.c memory.c buffer.c table.c hash.c \
 	filter.c routemap.c distribute.c stream.c str.c log.c plist.c \
 	zclient.c sockopt.c smux.c md5.c if_rmap.c keychain.c privs.c \
-	sigevent.c pqueue.c jhash.c memtypes.c workqueue.c
+	sigevent.c pqueue.c jhash.c memtypes.c workqueue.c bfd.c
 
 BUILT_SOURCES = memtypes.h route_types.h
 
@@ -27,7 +27,7 @@ pkginclude_HEADERS = \
 	str.h stream.h table.h thread.h vector.h version.h vty.h zebra.h \
 	plist.h zclient.h sockopt.h smux.h md5.h if_rmap.h keychain.h \
 	privs.h sigevent.h pqueue.h jhash.h zassert.h memtypes.h \
-	workqueue.h route_types.h
+	workqueue.h route_types.h bfd.h
 
 EXTRA_DIST = regex.c regex-gnu.h memtypes.awk route_types.awk route_types.txt
 
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/memory.c quagga-0.99.9-bfd-0.90.1/lib/memory.c
--- quagga-0.99.9/lib/memory.c	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/memory.c	2007-10-21 01:09:15.000000000 +0200
@@ -397,6 +397,17 @@ DEFUN (show_memory_ripng,
   return CMD_SUCCESS;
 }
 
+DEFUN (show_memory_bfd,
+       show_memory_bfd_cmd,
+       "show memory bfd",
+       SHOW_STR
+       "Memory statistics\n"
+       "BFD memory\n")
+{
+  show_memory_vty (vty, memory_list_bfd);
+  return CMD_SUCCESS;
+}
+
 DEFUN (show_memory_bgp,
        show_memory_bgp_cmd,
        "show memory bgp",
@@ -449,6 +460,7 @@ memory_init (void)
   install_element (VIEW_NODE, &show_memory_lib_cmd);
   install_element (VIEW_NODE, &show_memory_rip_cmd);
   install_element (VIEW_NODE, &show_memory_ripng_cmd);
+  install_element (VIEW_NODE, &show_memory_bfd_cmd);
   install_element (VIEW_NODE, &show_memory_bgp_cmd);
   install_element (VIEW_NODE, &show_memory_ospf_cmd);
   install_element (VIEW_NODE, &show_memory_ospf6_cmd);
@@ -460,6 +472,7 @@ memory_init (void)
   install_element (ENABLE_NODE, &show_memory_zebra_cmd);
   install_element (ENABLE_NODE, &show_memory_rip_cmd);
   install_element (ENABLE_NODE, &show_memory_ripng_cmd);
+  install_element (ENABLE_NODE, &show_memory_bfd_cmd);
   install_element (ENABLE_NODE, &show_memory_bgp_cmd);
   install_element (ENABLE_NODE, &show_memory_ospf_cmd);
   install_element (ENABLE_NODE, &show_memory_ospf6_cmd);
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/memtypes.c quagga-0.99.9-bfd-0.90.1/lib/memtypes.c
--- quagga-0.99.9/lib/memtypes.c	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/memtypes.c	2007-10-21 01:09:15.000000000 +0200
@@ -88,6 +88,21 @@ struct memory_list memory_list_zebra[] =
   { -1, NULL },
 };
 
+struct memory_list memory_list_bfd[] =
+{
+  { MTYPE_BFD,                  "BFD instance"			},
+  { MTYPE_BFD_LPORT,            "BFD lport"			},
+  { MTYPE_BFD_NEIGHSTRUCT,      "BFD table pointer"	        },
+  { MTYPE_BFD_CNEIGHTBL,        "BFD candidate table"	        },
+  { MTYPE_BFD_NEIGHTBL,         "BFD neighbor table"	        },
+  { 0, NULL },
+  { MTYPE_BFD_ADDRTREEHDR,      "BFD addrtreehdr"               },
+  { MTYPE_BFD_IF_INFO,          "BFD interface"                 },
+  { MTYPE_BFD_NEIGH,            "BFD neighbor"                  },
+  { MTYPE_BFD_CNEIGH,           "BFD candidate neighbor"        },
+  { -1, NULL },
+};
+
 struct memory_list memory_list_bgp[] =
 {
   { MTYPE_BGP,			"BGP instance"			},
@@ -258,5 +273,6 @@ struct mlist mlists[] __attribute__ ((un
   { memory_list_ospf6,	"OSPF6"	},
   { memory_list_isis,	"ISIS"	},
   { memory_list_bgp,	"BGP"	},
+  { memory_list_bfd,	"BFD"	},
   { NULL, NULL},
 };
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/memtypes.h quagga-0.99.9-bfd-0.90.1/lib/memtypes.h
--- quagga-0.99.9/lib/memtypes.h	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/memtypes.h	2007-10-21 01:09:15.000000000 +0200
@@ -72,6 +72,15 @@ enum
   MTYPE_RIB_QUEUE,
   MTYPE_STATIC_IPV4,
   MTYPE_STATIC_IPV6,
+  MTYPE_BFD,
+  MTYPE_BFD_LPORT,
+  MTYPE_BFD_NEIGHSTRUCT,
+  MTYPE_BFD_CNEIGHTBL,
+  MTYPE_BFD_NEIGHTBL,
+  MTYPE_BFD_ADDRTREEHDR,
+  MTYPE_BFD_IF_INFO,
+  MTYPE_BFD_NEIGH,
+  MTYPE_BFD_CNEIGH,
   MTYPE_BGP,
   MTYPE_BGP_PEER,
   MTYPE_BGP_PEER_HOST,
@@ -194,6 +203,7 @@ enum
 
 extern struct memory_list memory_list_lib[];
 extern struct memory_list memory_list_zebra[];
+extern struct memory_list memory_list_bfd[];
 extern struct memory_list memory_list_bgp[];
 extern struct memory_list memory_list_rip[];
 extern struct memory_list memory_list_ripng[];
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/prefix.c quagga-0.99.9-bfd-0.90.1/lib/prefix.c
--- quagga-0.99.9/lib/prefix.c	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/prefix.c	2007-10-21 01:09:15.000000000 +0200
@@ -569,6 +569,30 @@ sockunion2hostprefix (const union sockun
   return NULL;
 }
 
+union sockunion*
+hostprefix2sockunion (const struct prefix *p)
+{
+  if(p->family == AF_INET)
+  {
+    union sockunion *su;
+    su = XCALLOC(MTYPE_SOCKUNION, sizeof(union sockunion));
+    su->sa.sa_family = AF_INET;
+    su->sin.sin_addr = ((struct prefix_ipv4*)p)->prefix;
+    return su;
+  }
+#ifdef HAVE_IPV6
+  if(p->family == AF_INET6)
+  {
+    union sockunion *su;
+    su = XCALLOC(MTYPE_SOCKUNION, sizeof(union sockunion));
+    su->sa.sa_family = AF_INET6;
+    memcpy (&su->sin6.sin6_addr, &((struct prefix_ipv6*)p)->prefix, sizeof(struct in6_addr));
+    return su;
+  }
+#endif /* HAVE_IPV6 */
+  return NULL;
+}
+
 int
 prefix_blen (const struct prefix *p)
 {
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/prefix.h quagga-0.99.9-bfd-0.90.1/lib/prefix.h
--- quagga-0.99.9/lib/prefix.h	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/prefix.h	2007-10-21 01:09:15.000000000 +0200
@@ -146,6 +146,7 @@ extern void apply_mask (struct prefix *)
 extern struct prefix *sockunion2prefix (const union sockunion *dest,
                                         const union sockunion *mask);
 extern struct prefix *sockunion2hostprefix (const union sockunion *);
+extern union sockunion* hostprefix2sockunion (const struct prefix *p);
 
 extern struct prefix_ipv4 *prefix_ipv4_new (void);
 extern void prefix_ipv4_free (struct prefix_ipv4 *);
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/thread.h quagga-0.99.9-bfd-0.90.1/lib/thread.h
--- quagga-0.99.9/lib/thread.h	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/thread.h	2007-10-21 01:09:15.000000000 +0200
@@ -135,6 +135,12 @@ enum quagga_clkid {
       thread = thread_add_timer (master, func, arg, time); \
   } while (0)
 
+#define THREAD_TIMER_MSEC_ON(master,thread,func,arg,time) \
+  do { \
+    if (! thread) \
+      thread = thread_add_timer_msec (master, func, arg, time); \
+  } while (0)
+
 #define THREAD_OFF(thread) \
   do { \
     if (thread) \
@@ -190,6 +196,7 @@ extern unsigned int thread_cancel_event 
 extern struct thread *thread_fetch (struct thread_master *, struct thread *);
 extern void thread_call (struct thread *);
 extern unsigned long thread_timer_remain_second (struct thread *);
+extern unsigned long thread_timer_remain_msecond (struct thread *thread);
 extern int thread_should_yield (struct thread *);
 
 /* Internal libzebra exports */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/zclient.c quagga-0.99.9-bfd-0.90.1/lib/zclient.c
--- quagga-0.99.9/lib/zclient.c	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/zclient.c	2007-10-21 01:09:15.000000000 +0200
@@ -32,6 +32,10 @@
 #include "zclient.h"
 #include "memory.h"
 #include "table.h"
+#include "bfd.h"
+#include "zebra/zserv_bfd.h"
+
+
 
 /* Zebra client events. */
 enum event {ZCLIENT_SCHEDULE, ZCLIENT_READ, ZCLIENT_CONNECT};
@@ -41,6 +45,8 @@ static void zclient_event (enum event, s
 
 extern struct thread_master *master;
 
+extern struct cneightbl *cneightbl;
+
 /* This file local debug flag. */
 int zclient_debug = 0;
 
@@ -349,6 +355,10 @@ zclient_start (struct zclient *zclient)
   /* We need router-id information. */
   zebra_message_send (zclient, ZEBRA_ROUTER_ID_ADD);
 
+  /* If I'm a bfdd then register myself at zebra */
+  if(zclient->flags & ZCLIENT_FLAGS_BFDD)
+    zapi_bfd_register(zclient);
+
   /* Flush all redistribute request. */
   for (i = 0; i < ZEBRA_ROUTE_MAX; i++)
     if (i != zclient->redist_default && zclient->redist[i])
@@ -535,6 +545,164 @@ zapi_ipv6_route (u_char cmd, struct zcli
 }
 #endif /* HAVE_IPV6 */
 
+
+/* Register message is used to cell zebra that the client
+   who sent it is the BFD deamon */
+int 
+zapi_bfd_register(struct zclient *zclient)
+{   
+  struct stream *s;
+
+  s = zclient->obuf;
+  stream_reset(s);
+  zclient_create_header(s, ZEBRA_BFD_REGISTER);
+      
+  return zclient_send_message(zclient);
+}
+
+/* Functions (one for each family)  provide an interface 
+   for adding/removing candidate neighbors which might 
+   (or might not) become bfd sessions (called "neighbors" internally). 
+   Add/del messages are normally sent by BFD clients like BGP for example.*/
+int
+zapi_ipv4_bfd_cneigh_adddel(struct zclient *zclient, int cmd, 
+			    struct prefix_ipv4 *rp, struct prefix_ipv4 *lp, 
+			    unsigned int ifindex, uint32_t flags) 
+{
+  struct stream *s;
+
+  s = zclient->obuf;
+  stream_reset (s);
+
+  switch(cmd) {
+    case BFD_CNEIGH_ADD:
+      zclient_create_header(s, ZEBRA_IPV4_BFD_CNEIGH_ADD);
+      break;
+    case BFD_CNEIGH_DEL:
+      zclient_create_header(s, ZEBRA_IPV4_BFD_CNEIGH_DEL);
+      break;
+    default:
+      abort();
+  }
+
+  stream_write(s, (u_char *)&rp->prefix, IPV4_MAX_BYTELEN);
+  stream_write(s, (u_char *)&lp->prefix, IPV4_MAX_BYTELEN);
+
+  stream_putl(s,ifindex);
+
+  stream_putl(s,flags);
+
+  /* Write packet size. */
+  stream_putw_at (s, 0, stream_get_endp (s));
+
+  return zclient_send_message(zclient);
+}
+#ifdef HAVE_IPV6
+int 
+zapi_ipv6_bfd_cneigh_adddel(struct zclient *zclient, int cmd, 
+			    struct prefix_ipv6 *rp, struct prefix_ipv6 *lp, 
+			    unsigned int ifindex, uint32_t flags) 
+{
+  struct stream *s;
+
+  s = zclient->obuf;
+  stream_reset (s);
+
+  switch(cmd) {
+    case BFD_CNEIGH_ADD:
+      zclient_create_header(s, ZEBRA_IPV6_BFD_CNEIGH_ADD);
+      break;
+    case BFD_CNEIGH_DEL:
+      zclient_create_header(s, ZEBRA_IPV6_BFD_CNEIGH_DEL);
+      break;
+    default:
+      abort();
+  }
+
+  stream_write(s, (u_char *)&rp->prefix, IPV6_MAX_BYTELEN);
+  stream_write(s, (u_char *)&lp->prefix, IPV6_MAX_BYTELEN);
+
+  stream_putl(s,ifindex);
+
+  stream_putl(s,flags);
+
+  /* Write packet size. */
+  stream_putw_at (s, 0, stream_get_endp (s));
+
+  return zclient_send_message(zclient);
+}
+#endif /* HAVE_IPV6 */
+
+/* Functions (one of each family) are responsible for sending 
+   up/down messages which carries information about session 
+   state transitions. Normally BFD deamon is the deamon that 
+   uses these functions */
+int
+zapi_ipv4_bfd_neigh_updown(struct zclient *zclient, int cmd, 
+			   struct prefix_ipv4 *rp, struct prefix_ipv4 *lp, 
+			   unsigned int ifindex) 
+{
+  struct stream *s;
+
+  s = zclient->obuf;
+  stream_reset (s);
+
+  switch(cmd) {
+    case BFD_NEIGH_UP:
+      zclient_create_header(s, ZEBRA_IPV4_BFD_NEIGH_UP);
+      break;
+    case BFD_NEIGH_DOWN:
+      zclient_create_header(s,  ZEBRA_IPV4_BFD_NEIGH_DOWN);
+      break;
+    default:
+      abort();
+  }
+
+  stream_write(s, (u_char *)&rp->prefix, IPV4_MAX_BYTELEN);
+  stream_write(s, (u_char *)&lp->prefix, IPV4_MAX_BYTELEN);
+
+  stream_putl(s,ifindex);
+
+  stream_putl(s,0); /* Flags values are not important */
+
+  stream_putw_at (s, 0, stream_get_endp (s));
+
+  return zclient_send_message(zclient);
+}
+#ifdef HAVE_IPV6
+int
+zapi_ipv6_bfd_neigh_updown(struct zclient *zclient, int cmd, struct prefix_ipv6 *rp, struct prefix_ipv6 *lp, unsigned int ifindex) 
+{
+  struct stream *s;
+
+  s = zclient->obuf;
+  stream_reset (s);
+
+  switch(cmd) {
+    case BFD_NEIGH_UP:
+      zclient_create_header(s, ZEBRA_IPV6_BFD_NEIGH_UP);
+      break;
+    case BFD_NEIGH_DOWN:
+      zclient_create_header(s,  ZEBRA_IPV6_BFD_NEIGH_DOWN);
+      break;
+    default:
+      abort();
+  }
+
+  stream_write(s, (u_char *)&rp->prefix, IPV6_MAX_BYTELEN);
+  stream_write(s, (u_char *)&lp->prefix, IPV6_MAX_BYTELEN);
+
+  stream_putl(s,ifindex);
+
+  stream_putl(s,0); /* Flags values are not important */
+
+  stream_putw_at (s, 0, stream_get_endp (s));
+
+  return zclient_send_message(zclient);
+}
+#endif /* HAVE_IPV6 */
+
+
 /* 
  * send a ZEBRA_REDISTRIBUTE_ADD or ZEBRA_REDISTRIBUTE_DELETE
  * for the route type (ZEBRA_ROUTE_KERNEL etc.). The zebra server will
@@ -636,6 +804,53 @@ zebra_interface_add_read (struct stream 
   return ifp;
 }
 
+/* Functions (one for each family) are responsible
+   for reading add/del messages. */
+struct bfd_cneigh*
+ipv4_bfd_cneigh_adddel_read(struct stream *s)
+{
+  struct bfd_cneigh *cneighp;
+  cneighp = bfd_cneigh_new();
+  
+  cneighp->raddr.family = AF_INET;
+  cneighp->raddr.prefixlen = IPV4_MAX_PREFIXLEN;
+  stream_get(&cneighp->raddr.u.prefix, s, IPV4_MAX_BYTELEN);
+  
+  cneighp->laddr.family = AF_INET;
+  cneighp->laddr.prefixlen = IPV4_MAX_PREFIXLEN;
+  stream_get(&cneighp->laddr.u.prefix, s, IPV4_MAX_BYTELEN);
+
+  cneighp->ifindex = stream_getl(s);
+  
+  cneighp->flags = stream_getl(s);
+  
+  return cneighp;
+}
+#ifdef HAVE_IPV6
+struct bfd_cneigh*
+ipv6_bfd_cneigh_adddel_read(struct stream *s)
+{
+  struct bfd_cneigh *cneighp;
+  cneighp = bfd_cneigh_new();
+  
+  cneighp->raddr.family = AF_INET6;
+  cneighp->raddr.prefixlen = IPV6_MAX_PREFIXLEN;
+  stream_get(&cneighp->raddr.u.prefix, s, IPV6_MAX_BYTELEN);
+  
+  cneighp->laddr.family = AF_INET6;
+  cneighp->laddr.prefixlen = IPV6_MAX_PREFIXLEN;
+  stream_get(&cneighp->laddr.u.prefix, s, IPV6_MAX_BYTELEN);
+
+  cneighp->ifindex = stream_getl(s);
+  
+  cneighp->flags = stream_getl(s);
+  
+  return cneighp;
+}
+#endif /* HAVE_IPV6 */
+
+
+
 /* 
  * Read interface up/down msg (ZEBRA_INTERFACE_UP/ZEBRA_INTERFACE_DOWN)
  * from zebra server.  The format of this message is the same as
@@ -937,6 +1152,40 @@ zclient_read (struct thread *thread)
       if (zclient->ipv6_route_delete)
 	ret = (*zclient->ipv6_route_delete) (command, zclient, length);
       break;
+    case ZEBRA_IPV4_BFD_CNEIGH_ADD:
+      if (zclient->ipv4_bfd_cneigh_add)
+	ret = (*zclient->ipv4_bfd_cneigh_add) (command, zclient, length);
+      break;
+    case ZEBRA_IPV4_BFD_CNEIGH_DEL:
+      if (zclient->ipv4_bfd_cneigh_del)
+	ret = (*zclient->ipv4_bfd_cneigh_del) (command, zclient, length);
+      break;
+    case ZEBRA_IPV4_BFD_NEIGH_UP:
+      if (zclient->ipv4_bfd_neigh_up)
+	ret = (*zclient->ipv4_bfd_neigh_up) (command, zclient, length);
+      break;
+    case ZEBRA_IPV4_BFD_NEIGH_DOWN:
+      if (zclient->ipv4_bfd_neigh_down)
+	ret = (*zclient->ipv4_bfd_neigh_down) (command, zclient, length);
+      break;
+#ifdef HAVE_IPV6
+    case ZEBRA_IPV6_BFD_CNEIGH_ADD:
+      if (zclient->ipv6_bfd_cneigh_add)
+	ret = (*zclient->ipv6_bfd_cneigh_add) (command, zclient, length);
+      break;
+    case ZEBRA_IPV6_BFD_CNEIGH_DEL:
+      if (zclient->ipv6_bfd_cneigh_del)
+	ret = (*zclient->ipv6_bfd_cneigh_del) (command, zclient, length);
+      break;
+    case ZEBRA_IPV6_BFD_NEIGH_UP:
+      if (zclient->ipv6_bfd_neigh_up)
+	ret = (*zclient->ipv6_bfd_neigh_up) (command, zclient, length);
+      break;
+    case ZEBRA_IPV6_BFD_NEIGH_DOWN:
+      if (zclient->ipv6_bfd_neigh_down)
+	ret = (*zclient->ipv6_bfd_neigh_down) (command, zclient, length);
+      break;
+#endif /* HAVE_IPV6 */
     default:
       break;
     }
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/zclient.h quagga-0.99.9-bfd-0.90.1/lib/zclient.h
--- quagga-0.99.9/lib/zclient.h	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/zclient.h	2007-10-21 01:09:15.000000000 +0200
@@ -24,6 +24,7 @@
 
 /* For struct interface and struct connected. */
 #include "if.h"
+#include "prefix.h"
 
 /* For input/output buffer to zebra. */
 #define ZEBRA_MAX_PACKET_SIZ          4096
@@ -67,6 +68,11 @@ struct zclient
   /* Redistribute defauilt. */
   u_char default_information;
 
+/* If this flag is set the client is considered as bfdd */
+#define ZCLIENT_FLAGS_BFDD   0x1
+  /* Flags */
+  int flags;
+
   /* Pointer to the callback functions. */
   int (*router_id_update) (int, struct zclient *, uint16_t);
   int (*interface_add) (int, struct zclient *, uint16_t);
@@ -79,8 +85,21 @@ struct zclient
   int (*ipv4_route_delete) (int, struct zclient *, uint16_t);
   int (*ipv6_route_add) (int, struct zclient *, uint16_t);
   int (*ipv6_route_delete) (int, struct zclient *, uint16_t);
+
+  /* BFD */
+  int (*ipv4_bfd_cneigh_add) (int, struct zclient *, uint16_t);
+  int (*ipv4_bfd_cneigh_del) (int, struct zclient *, uint16_t);
+  int (*ipv4_bfd_neigh_up) (int, struct zclient *, uint16_t);
+  int (*ipv4_bfd_neigh_down) (int, struct zclient *, uint16_t);
+#ifdef HAVE_IPV6
+  int (*ipv6_bfd_cneigh_add) (int, struct zclient *, uint16_t);
+  int (*ipv6_bfd_cneigh_del) (int, struct zclient *, uint16_t);
+  int (*ipv6_bfd_neigh_up) (int, struct zclient *, uint16_t);
+  int (*ipv6_bfd_neigh_down) (int, struct zclient *, uint16_t);
+#endif /* HAVE_IPV6 */
 };
 
+
 /* Zebra API message flag. */
 #define ZAPI_MESSAGE_NEXTHOP  0x01
 #define ZAPI_MESSAGE_IFINDEX  0x02
@@ -156,6 +175,49 @@ extern void zebra_router_id_update_read 
 extern int zapi_ipv4_route (u_char, struct zclient *, struct prefix_ipv4 *, 
                             struct zapi_ipv4 *);
 
+
+/* BFD: Register message */
+int zapi_bfd_register(struct zclient *);
+
+/* BFD: Add/Remove candidate neighbor */
+#define BFD_CNEIGH_ADD 1
+#define BFD_CNEIGH_DEL 2
+#define zapi_ipv4_bfd_cneigh_add(C,RP,LP,I,F) zapi_ipv4_bfd_cneigh_adddel(C,BFD_CNEIGH_ADD,RP,LP,I,F)
+#define zapi_ipv4_bfd_cneigh_del(C,RP,LP,I,F) zapi_ipv4_bfd_cneigh_adddel(C,BFD_CNEIGH_DEL,RP,LP,I,F)
+extern int zapi_ipv4_bfd_cneigh_adddel(struct zclient *zclient, int cmd, 
+				       struct prefix_ipv4 *rp, 
+				       struct prefix_ipv4 *lp,
+				       unsigned int ifindex, uint32_t flags);
+extern struct bfd_cneigh* ipv4_bfd_cneigh_adddel_read(struct stream *);
+#ifdef HAVE_IPV6
+#define zapi_ipv6_bfd_cneigh_add(C,RP,LP,I,F) zapi_ipv6_bfd_cneigh_adddel(C,BFD_CNEIGH_ADD,RP,LP,I,F)
+#define zapi_ipv6_bfd_cneigh_del(C,RP,LP,I,F) zapi_ipv6_bfd_cneigh_adddel(C,BFD_CNEIGH_DEL,RP,LP,I,F)
+int zapi_ipv6_bfd_cneigh_adddel(struct zclient *zclient, int cmd, 
+				struct prefix_ipv6 *rp, 
+				struct prefix_ipv6 *lp, 
+				unsigned int ifindex, uint32_t flags);
+extern struct bfd_cneigh* ipv6_bfd_cneigh_adddel_read(struct stream *);
+#endif /* HAVE_IPV6 */
+
+/* BFD: Signalize Up/Down state */
+#define BFD_NEIGH_UP   1
+#define BFD_NEIGH_DOWN 2
+#define zapi_ipv4_bfd_neigh_up(C,R,L,I)   zapi_ipv4_bfd_neigh_updown(C,BFD_NEIGH_UP,R,L.I)
+#define zapi_ipv4_bfd_neigh_down(C,R,L,I) zapi_ipv4_bfd_neigh_updown(C,BFD_NEIGH_DOWN,R,L,I)
+int zapi_ipv4_bfd_neigh_updown(struct zclient *zclient, int cmd, 
+			       struct prefix_ipv4 *rp, 
+			       struct prefix_ipv4 *lp, unsigned int ifindex);
+#define ipv4_bfd_neigh_updown_read(S) ipv4_bfd_cneigh_adddel_read(S)
+#ifdef HAVE_IPV6
+#define zapi_ipv6_bfd_neigh_up(C,R,L,I)   zapi_ipv6_bfd_neigh_updown(C,BFD_NEIGH_UP,R,L.I)
+#define zapi_ipv6_bfd_neigh_down(C,R,L,I) zapi_ipv6_bfd_neigh_updown(C,BFD_NEIGH_DOWN,R,L,I)
+int zapi_ipv6_bfd_neigh_updown(struct zclient *zclient, int cmd, 
+			       struct prefix_ipv6 *rp, 
+			       struct prefix_ipv6 *lp, unsigned int ifindex);
+#define ipv6_bfd_neigh_updown_read(S) ipv6_bfd_cneigh_adddel_read(S)
+#endif /* HAVE_IPV6 */
+
+
 #ifdef HAVE_IPV6
 /* IPv6 prefix add and delete function prototype. */
 
diff -Nupwbr --exclude=bgpd quagga-0.99.9/lib/zebra.h quagga-0.99.9-bfd-0.90.1/lib/zebra.h
--- quagga-0.99.9/lib/zebra.h	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/lib/zebra.h	2007-10-21 01:09:15.000000000 +0200
@@ -411,7 +411,20 @@ struct in_pktinfo
 #define ZEBRA_ROUTER_ID_ADD               20
 #define ZEBRA_ROUTER_ID_DELETE            21
 #define ZEBRA_ROUTER_ID_UPDATE            22
-#define ZEBRA_MESSAGE_MAX                 23
+
+#define ZEBRA_IPV4_BFD_CNEIGH_LIST        23
+#define ZEBRA_IPV6_BFD_CNEIGH_LIST        24
+#define ZEBRA_IPV4_BFD_CNEIGH_ADD         25
+#define ZEBRA_IPV4_BFD_CNEIGH_DEL         26
+#define ZEBRA_IPV6_BFD_CNEIGH_ADD         27
+#define ZEBRA_IPV6_BFD_CNEIGH_DEL         28
+#define ZEBRA_IPV4_BFD_NEIGH_UP           29
+#define ZEBRA_IPV4_BFD_NEIGH_DOWN         30
+#define ZEBRA_IPV6_BFD_NEIGH_UP           31
+#define ZEBRA_IPV6_BFD_NEIGH_DOWN         32
+#define ZEBRA_BFD_REGISTER                33
+
+#define ZEBRA_MESSAGE_MAX                 34
 
 /* Marker value used in new Zserv, in the byte location corresponding
  * the command value in the old zserv header. To allow old and new
@@ -431,7 +444,8 @@ struct in_pktinfo
 #define ZEBRA_ROUTE_ISIS                 8
 #define ZEBRA_ROUTE_BGP                  9
 #define ZEBRA_ROUTE_HSLS		 10
-#define ZEBRA_ROUTE_MAX                  11
+#define ZEBRA_ROUTE_BFD                  11
+#define ZEBRA_ROUTE_MAX                  12
 
 /* Note: whenever a new route-type or zserv-command is added the
  * corresponding {command,route}_types[] table in lib/log.c MUST be
diff -Nupwbr --exclude=bgpd quagga-0.99.9/Makefile.am quagga-0.99.9-bfd-0.90.1/Makefile.am
--- quagga-0.99.9/Makefile.am	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/Makefile.am	2007-10-21 01:12:31.000000000 +0200
@@ -1,10 +1,10 @@
 ## Process this file with automake to produce Makefile.in.
 
-SUBDIRS = lib @ZEBRA@ @BGPD@ @RIPD@ @RIPNGD@ @OSPFD@ @OSPF6D@ \
+SUBDIRS = lib @ZEBRA@ @BFDD@ @BGPD@ @RIPD@ @RIPNGD@ @OSPFD@ @OSPF6D@ \
          @ISISD@ @WATCHQUAGGA@ @VTYSH@ @OSPFCLIENT@ doc m4 @pkgsrcdir@ \
-         redhat @SOLARIS@
+	 redhat solaris
 
-DIST_SUBDIRS = lib zebra bgpd ripd ripngd ospfd ospf6d \
+DIST_SUBDIRS = lib zebra bfdd bgpd ripd ripngd ospfd ospf6d \
 	  isisd watchquagga vtysh ospfclient doc m4 pkgsrc redhat tests \
 	  solaris
 
diff -Nupwbr --exclude=bgpd quagga-0.99.9/pkgsrc/bfdd.sh.in quagga-0.99.9-bfd-0.90.1/pkgsrc/bfdd.sh.in
--- quagga-0.99.9/pkgsrc/bfdd.sh.in	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/pkgsrc/bfdd.sh.in	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,44 @@
+#!/bin/sh
+#
+# bfdd is part of the quagga routing beast
+#
+# PROVIDE: bfdd
+# REQUIRE: zebra
+##
+
+PATH=/sbin:/bin:/usr/sbin:/usr/bin:@prefix@/sbin:@prefix@/bin
+export PATH
+
+if [ -f /etc/rc.subr ]
+then
+	. /etc/rc.subr
+fi
+
+name="bfdd"
+rcvar=$name
+required_files="@sysconfdir@/${name}.conf"
+command="@prefix@/sbin/${name}"
+command_args="-d"
+
+start_precmd="zebra_precmd"
+socket_dir=@localstatedir@
+pidfile="${socket_dir}/${name}.pid"
+
+zebra_precmd()
+{
+    rc_flags="$(
+	set -- $rc_flags
+	while [ $# -ne 0 ]; do
+	    if [ X"$1" = X-P -o X"$1" = X-A ]; then
+		break
+	    fi
+	    shift
+	done
+	if [ $# -eq 0 ]; then
+	    echo "-P 0"
+	fi
+	) $rc_flags"
+}
+
+load_rc_config $name
+run_rc_command "$1"
diff -Nupwbr --exclude=bgpd quagga-0.99.9/pkgsrc/Makefile.am quagga-0.99.9-bfd-0.90.1/pkgsrc/Makefile.am
--- quagga-0.99.9/pkgsrc/Makefile.am	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/pkgsrc/Makefile.am	2007-10-21 01:09:15.000000000 +0200
@@ -1,3 +1,3 @@
 rcdir=@pkgsrcrcdir@
 
-rc_SCRIPTS = bgpd.sh ospf6d.sh ospfd.sh ripd.sh ripngd.sh zebra.sh
+rc_SCRIPTS = bfdd.sh bgpd.sh ospf6d.sh ospfd.sh ripd.sh ripngd.sh zebra.sh
diff -Nupwbr --exclude=bgpd quagga-0.99.9/vtysh/Makefile.am quagga-0.99.9-bfd-0.90.1/vtysh/Makefile.am
--- quagga-0.99.9/vtysh/Makefile.am	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/vtysh/Makefile.am	2007-10-21 01:09:15.000000000 +0200
@@ -18,7 +18,7 @@ dist_examples_DATA = vtysh.conf.sample
 
 EXTRA_DIST = extract.pl
 
-vtysh_cmd_FILES = $(top_srcdir)/bgpd/*.c $(top_srcdir)/isisd/*.c \
+vtysh_cmd_FILES = $(top_srcdir)/bfdd/*. $(top_srcdir)/bgpd/*.c $(top_srcdir)/isisd/*.c \
 		  $(top_srcdir)/ospfd/*.c $(top_srcdir)/ospf6d/*.c \
 		  $(top_srcdir)/ripd/*.c $(top_srcdir)/ripngd/*.c \
 		  $(top_srcdir)/lib/keychain.c $(top_srcdir)/lib/routemap.c \
diff -Nupwbr --exclude=bgpd quagga-0.99.9/zebra/main.c quagga-0.99.9-bfd-0.90.1/zebra/main.c
--- quagga-0.99.9/zebra/main.c	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/zebra/main.c	2007-10-21 01:09:15.000000000 +0200
@@ -35,6 +35,7 @@
 
 #include "zebra/rib.h"
 #include "zebra/zserv.h"
+#include "zebra/zserv_bfd.h"
 #include "zebra/debug.h"
 #include "zebra/router-id.h"
 #include "zebra/irdp.h"
@@ -342,6 +343,9 @@ main (int argc, char **argv)
   /* Sort VTY commands. */
   sort_node ();
 
+  /* BFD */
+  bfd_cneigh_init();
+
 #ifdef HAVE_SNMP
   zebra_snmp_init ();
 #endif /* HAVE_SNMP */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/zebra/Makefile.am quagga-0.99.9-bfd-0.90.1/zebra/Makefile.am
--- quagga-0.99.9/zebra/Makefile.am	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/zebra/Makefile.am	2007-10-21 01:09:15.000000000 +0200
@@ -24,7 +24,7 @@ sbin_PROGRAMS = zebra
 noinst_PROGRAMS = testzebra
 
 zebra_SOURCES = \
-	zserv.c main.c interface.c connected.c zebra_rib.c zebra_routemap.c \
+	zserv.c zserv_bfd.c main.c interface.c connected.c zebra_rib.c zebra_routemap.c \
 	redistribute.c debug.c rtadv.c zebra_snmp.c zebra_vty.c \
 	irdp_main.c irdp_interface.c irdp_packet.c router-id.c
 
@@ -33,7 +33,7 @@ testzebra_SOURCES = test_main.c zebra_ri
 	kernel_null.c  redistribute_null.c ioctl_null.c misc_null.c
 
 noinst_HEADERS = \
-	connected.h ioctl.h rib.h rt.h zserv.h redistribute.h debug.h rtadv.h \
+	connected.h ioctl.h rib.h rt.h zserv.h zserv_bfd.h redistribute.h debug.h rtadv.h \
 	interface.h ipforward.h irdp.h router-id.h kernel_socket.h
 
 zebra_LDADD = $(otherobj) $(LIBCAP) $(LIB_IPV6) ../lib/libzebra.la
diff -Nupwbr --exclude=bgpd quagga-0.99.9/zebra/zserv_bfd.c quagga-0.99.9-bfd-0.90.1/zebra/zserv_bfd.c
--- quagga-0.99.9/zebra/zserv_bfd.c	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/zebra/zserv_bfd.c	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,728 @@
+/*
+ * ZEBRA - zserv_bfd.c
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include <zebra.h>
+
+#include "prefix.h"
+#include "stream.h"
+#include "memory.h"
+#include "table.h"
+#include "log.h"
+#include "zclient.h"
+#include "linklist.h"
+
+#include "bfd.h"
+#include "zebra/zserv.h"
+#include "zebra/zserv_bfd.h"
+#include "zebra/debug.h"
+
+extern struct zebra_t zebrad;
+
+struct cneightbl *cneightbl;
+struct zserv *bfd_client = NULL;
+
+struct bfd_addrtreehdr
+{
+  int count;			/* Number of nodes in radix tree */
+  struct route_table *info;	/* BFD subnode tree, 
+				   for storing local addr part of socket */
+};
+
+
+struct cneightbl
+{
+  struct route_table *v4;
+#ifdef HAVE_IPV6
+  struct route_table *v6;
+#endif				/* HAVE_IPV6 */
+};
+
+static struct bfd_addrtreehdr *
+bfd_addrtreehdr_init (void)
+{
+  struct bfd_addrtreehdr *addrtreehdr =
+    XMALLOC (MTYPE_BFD_ADDRTREEHDR, sizeof (struct bfd_addrtreehdr));
+  addrtreehdr->count = 0;
+  addrtreehdr->info = route_table_init ();
+  return addrtreehdr;
+}
+
+static void
+bfd_addrtreehdr_free (struct bfd_addrtreehdr *hdrp)
+{
+  XFREE (MTYPE_BFD_ADDRTREEHDR, hdrp);
+}
+
+
+/* BFD candidate neighbor init */
+void
+bfd_cneigh_init (void)
+{
+  cneightbl = XCALLOC (MTYPE_BFD_CNEIGHTBL, sizeof (struct cneightbl));
+  cneightbl->v4 = route_table_init ();
+#ifdef HAVE_IPV6
+  cneightbl->v6 = route_table_init ();
+#endif /* HAVE_IPV6 */
+}
+
+static int
+zsend_bfd_cneigh_adddel (struct bfd_cneigh *cneighp, int header, int len)
+{
+  struct stream *s;
+
+  if (bfd_client)
+    s = bfd_client->obuf;
+  else
+    return -1;
+
+  stream_reset (s);
+
+  zserv_create_header (s, header);
+
+  stream_write (s, (u_char *) & cneighp->raddr.u.prefix, len);
+  stream_write (s, (u_char *) & cneighp->laddr.u.prefix, len);
+
+  stream_putl (s, cneighp->ifindex);
+
+  stream_putl (s, cneighp->flags);
+
+  /* Write packet size. */
+  stream_putw_at (s, 0, stream_get_endp (s));
+
+  return zebra_server_send_message (bfd_client);
+}
+
+static int
+zsend_ipv4_bfd_cneigh_add (struct bfd_cneigh *cneighp)
+{
+  return zsend_bfd_cneigh_adddel (cneighp, ZEBRA_IPV4_BFD_CNEIGH_ADD,
+				  IPV4_MAX_BYTELEN);
+}
+
+static int
+zsend_ipv4_bfd_cneigh_del (struct bfd_cneigh *cneighp)
+{
+  return zsend_bfd_cneigh_adddel (cneighp, ZEBRA_IPV4_BFD_CNEIGH_DEL,
+				  IPV4_MAX_BYTELEN);
+}
+
+#ifdef HAVE_IPV6
+static int
+zsend_ipv6_bfd_cneigh_add (struct bfd_cneigh *cneighp)
+{
+  return zsend_bfd_cneigh_adddel (cneighp, ZEBRA_IPV6_BFD_CNEIGH_ADD,
+				  IPV6_MAX_BYTELEN);
+}
+
+static int
+zsend_ipv6_bfd_cneigh_del (struct bfd_cneigh *cneighp)
+{
+  return zsend_bfd_cneigh_adddel (cneighp, ZEBRA_IPV6_BFD_CNEIGH_DEL,
+				  IPV6_MAX_BYTELEN);
+}
+#endif /* HAVE_IPV6 */
+
+
+static int
+zsend_bfd_neigh_updown (struct zserv *client, struct bfd_cneigh *cneighp,
+			int header, int len)
+{
+  struct stream *s = client->obuf;
+
+  stream_reset (s);
+
+  zserv_create_header (s, header);
+
+  stream_write (s, (u_char *) & cneighp->raddr.u.prefix, len);
+  stream_write (s, (u_char *) & cneighp->laddr.u.prefix, len);
+
+  stream_putl (s, cneighp->ifindex);
+
+  stream_putl (s, cneighp->flags);
+
+  /* Write packet size. */
+  stream_putw_at (s, 0, stream_get_endp (s));
+
+  return zebra_server_send_message (client);
+}
+
+static int
+zsend_ipv4_bfd_neigh_up (struct zserv *client, struct bfd_cneigh *cneighp)
+{
+  return zsend_bfd_neigh_updown (client, cneighp, ZEBRA_IPV4_BFD_NEIGH_UP,
+				 IPV4_MAX_BYTELEN);
+}
+
+static int
+zsend_ipv4_bfd_neigh_down (struct zserv *client, struct bfd_cneigh *cneighp)
+{
+  return zsend_bfd_neigh_updown (client, cneighp, ZEBRA_IPV4_BFD_NEIGH_DOWN,
+				 IPV4_MAX_BYTELEN);
+}
+
+#ifdef HAVE_IPV6
+static int
+zsend_ipv6_bfd_neigh_up (struct zserv *client, struct bfd_cneigh *cneighp)
+{
+  return zsend_bfd_neigh_updown (client, cneighp, ZEBRA_IPV6_BFD_NEIGH_UP,
+				 IPV6_MAX_BYTELEN);
+}
+
+static int
+zsend_ipv6_bfd_neigh_down (struct zserv *client, struct bfd_cneigh *cneighp)
+{
+  return zsend_bfd_neigh_updown (client, cneighp, ZEBRA_IPV6_BFD_NEIGH_DOWN,
+				 IPV6_MAX_BYTELEN);
+}
+#endif /* HAVE_IPV6 */
+
+
+
+/* When receive register message send list of candidate neighbors back */
+int
+zread_bfd_register (struct zserv *client, u_short length)
+{
+  bfd_client = client;
+  zread_ipv4_bfd_cneigh_list (client, length);
+#ifdef HAVE_IPV6
+  zread_ipv6_bfd_cneigh_list (client, length);
+#endif /* HAVE_IPV6 */
+  return 0;
+}
+
+/* For list request send back the whole content of cneightable by creating
+   one cneigh_add message for every position in the table */
+static int
+zread_bfd_cneigh_list (struct zserv *client, struct route_table *cneightable,
+		       int family)
+{
+  struct route_node *node, *subnode;
+  int ret;
+
+  for (node = route_top (cneightable); node != NULL; node = route_next (node))
+    if (!node->info)
+      continue;
+    else
+      for (subnode =
+	   route_top (((struct bfd_addrtreehdr *) node->info)->info);
+	   subnode != NULL; subnode = route_next (subnode))
+	if (!subnode->info)
+	  continue;
+	else
+	  {
+	    if (family == AF_INET)
+	      ret = zsend_ipv4_bfd_cneigh_add (subnode->info);
+	    else
+	      ret = zsend_ipv6_bfd_cneigh_add (subnode->info);
+	    if (!ret)
+	      return -1;
+	  }
+  return 0;
+}
+
+/* On candidate neighbors list request send send list back */
+int
+zread_ipv4_bfd_cneigh_list (struct zserv *client, u_short length)
+{
+  return zread_bfd_cneigh_list (client, cneightbl->v4, AF_INET);
+}
+
+#ifdef HAVE_IPV6
+int
+zread_ipv6_bfd_cneigh_list (struct zserv *client, u_short length)
+{
+  return zread_bfd_cneigh_list (client, cneightbl->v6, AF_INET6);
+}
+#endif /* HAVE_IPV6 */
+
+
+/* Extracts candidate neighbor structure from a stream */
+static struct bfd_cneigh *
+zread_bfd_cneigh_extract (struct zserv *client, int family, int bytelen,
+			  u_char bitlen)
+{
+  struct stream *s;
+  struct bfd_cneigh *cneighp;
+
+  /* Get input stream.  */
+  s = client->ibuf;
+
+  /* Allocate memory for a candidate neighbor */
+  cneighp = bfd_cneigh_new ();
+
+  cneighp->raddr.family = family;
+  cneighp->raddr.prefixlen = bitlen;
+  stream_get (&cneighp->raddr.u.prefix, s, bytelen);
+
+  cneighp->laddr.family = family;
+  cneighp->laddr.prefixlen = bitlen;
+  stream_get (&cneighp->laddr.u.prefix, s, bytelen);
+
+  cneighp->ifindex = stream_getl (s);
+
+  cneighp->flags = stream_getl (s);
+
+  return cneighp;
+}
+
+#define zread_ipv4_bfd_cneigh_extract(C) \
+zread_bfd_cneigh_extract(C,AF_INET,IPV4_MAX_BYTELEN,IPV4_MAX_PREFIXLEN)
+#ifdef HAVE_IPV6
+#define zread_ipv6_bfd_cneigh_extract(C) \
+zread_bfd_cneigh_extract(C,AF_INET6,IPV6_MAX_BYTELEN,IPV6_MAX_PREFIXLEN)
+#endif /* HAVE_IPV6 */
+
+/*
+   Candidate's database structure:
+
+   struct cneightbl________
+   |struct route_table *v4 |------------> N
+   |struct route_table *v6 |             / \
+   |_______________________|            N   N
+                                       / \ / \
+                                              |
+                                              V    [node]
+                                              struct route_node
+                                              |void *info     |-------\
+                                              |...            |       |
+                                              |_______________|       |
+                                                                      |
+                                                                      |
+                                                                      |
+                                             struct bfd_addrtreehdr___V
+                                      S <----|struct route_table *info |
+                                     / \     |int count                |
+                                    S   S    |_________________________|
+                                   / \ / \
+                                          |
+                                          V   [subnode]
+                                          struct route_node
+               struct bfd_cneigh____ <----|void *info     |
+   /-----------|struct list *clients|     |...            |
+   |           |...                 |     |_______________|
+   |           |____________________|
+   V
+   struct zserv *client1
+   struct zserv *client2
+   struct zserv *client3
+
+
+*/
+/*
+   Function adds candidates to database, in order to do that 
+   have to check if candidate was already registered or not.
+   Possible scenarios are:
+   - new candidate is registered 
+   - candidate exists
+   in 2nd case client will be added to the list of clients 
+   that tracks state changes of this particular candidate neighbor */
+static int
+zread_bfd_cneigh_add (struct zserv *client, struct route_table *cneightable,
+		      struct bfd_cneigh *cneighp,
+		      int (*zsend_bfd_cneigh_add) (struct bfd_cneigh *))
+{
+  struct route_node *node, *subnode;
+  struct listnode *listnode;
+  struct zserv *zservp;
+  struct bfd_addrtreehdr *hdrp;
+
+  if (IS_ZEBRA_DEBUG_EVENT)
+    {
+      char rpbuf[BUFSIZ];
+      char lpbuf[BUFSIZ];
+      prefix2str (&cneighp->raddr, rpbuf, sizeof (rpbuf));
+      prefix2str (&cneighp->laddr, lpbuf, sizeof (lpbuf));
+      zlog_debug
+	("%s: new candidate neighbor <raddr=%s, laddr=%s, ifindex=%d, flags=%d>\n",
+	 __func__, rpbuf, lpbuf, cneighp->ifindex, cneighp->flags);
+    }
+
+  if ((node = route_node_lookup (cneightable, &cneighp->raddr)))
+    {
+      /* Peer address (raddr) found */
+      assert (node->info);
+      hdrp = (struct bfd_addrtreehdr *) node->info;
+      assert (hdrp->info);
+      assert (hdrp->count);
+
+      if ((subnode = route_node_lookup (hdrp->info, &cneighp->laddr)))
+	{
+	  /* Local address found */
+	  assert (subnode->info);
+	  for (ALL_LIST_ELEMENTS_RO
+	       (((struct bfd_cneigh *) subnode->info)->clients, listnode,
+		zservp))
+	    if (client == zservp)
+	      {
+		if (IS_ZEBRA_DEBUG_EVENT)
+		  zlog_debug ("%s: neighbor already registered by client",
+			      __func__);
+		/* Since we have one copy of candidate neighbor already within database
+		   we can free this one */
+		bfd_cneigh_free (cneighp);
+		return -1;	/* neighbor already registered by client */
+	      }
+
+	  /* Another client has registered the same candidate neighbor,
+	     add client to the list so that every state change will be send to it */
+	  listnode_add (((struct bfd_cneigh *) subnode->info)->clients,
+			client);
+	  if (IS_ZEBRA_DEBUG_EVENT)
+	    zlog_debug ("%s: another client has registered the"
+			"same neighbor - adding client to the list",
+			__func__);
+	  /* Since we have one copy of candidate neighbor already within database
+	     we can free this one */
+	  bfd_cneigh_free (cneighp);
+	  return 0;
+	}
+      else
+	{
+	  if (IS_ZEBRA_DEBUG_EVENT)
+	    zlog_debug ("%s: candidate neighbor already exists but local"
+			"address is different - adding new local address ",
+			__func__);
+
+	  /* Candidate neighbor already exists but a transport address 
+	     (local binding) is different */
+	  hdrp = (struct bfd_addrtreehdr *) node->info;
+	  hdrp->count++;
+	  subnode = route_node_get (hdrp->info, &cneighp->laddr);	/* Add new laddr */
+	  subnode->info = cneighp;
+	  cneighp->clients = list_new ();
+	  listnode_add (cneighp->clients, client);
+	  /* Send "Add" message to bfdd */
+	  zsend_bfd_cneigh_add (cneighp);
+	  return 0;
+	}
+    }
+  else
+    {
+      /* New neighbor */
+      if (IS_ZEBRA_DEBUG_EVENT)
+	{
+	  char rpbuf[BUFSIZ];
+	  char lpbuf[BUFSIZ];
+	  prefix2str (&cneighp->raddr, rpbuf, sizeof (rpbuf));
+	  prefix2str (&cneighp->laddr, lpbuf, sizeof (lpbuf));
+	  zlog_debug
+	    ("%s: new candidate neighbor <raddr=%s, laddr=%s, ifindex=%d, flags=%d>",
+	     __func__, rpbuf, lpbuf, cneighp->ifindex, cneighp->flags);
+	}
+      node = route_node_get (cneightable, &cneighp->raddr);
+      node->info = bfd_addrtreehdr_init ();
+      hdrp = (struct bfd_addrtreehdr *) node->info;
+      hdrp->count++;
+      subnode = route_node_get (hdrp->info, &cneighp->laddr);
+      subnode->info = cneighp;
+      cneighp->clients = list_new ();
+      listnode_add (cneighp->clients, client);
+      /* Send "Add" message to bfdd */
+      zsend_bfd_cneigh_add (cneighp);
+      return 0;
+    }
+}
+
+/* Preprocess candidate neighbor addition */
+int
+zread_ipv4_bfd_cneigh_add (struct zserv *client, u_short length)
+{
+  return zread_bfd_cneigh_add (client, cneightbl->v4,
+			       zread_ipv4_bfd_cneigh_extract (client),
+			       &zsend_ipv4_bfd_cneigh_add);
+}
+
+/* Preprocess candidate neighbor addition */
+#ifdef HAVE_IPV6
+int
+zread_ipv6_bfd_cneigh_add (struct zserv *client, u_short length)
+{
+  return zread_bfd_cneigh_add (client, cneightbl->v6,
+			       zread_ipv6_bfd_cneigh_extract (client),
+			       &zsend_ipv6_bfd_cneigh_add);
+}
+#endif /* HAVE_IPV6 */
+
+/* Remove candidate neighbor from candidate's database */
+static int
+zread_bfd_cneigh_del (struct zserv *client, struct route_table *cneightable,
+		      struct bfd_cneigh *cneighp,
+		      int (*zsend_bfd_cneigh_del) (struct bfd_cneigh *))
+{
+  struct route_node *node, *subnode;
+  struct listnode *listnode;
+  struct zserv *zservp;
+  struct bfd_addrtreehdr *hdrp;
+
+  if ((node = route_node_lookup (cneightable, &cneighp->raddr)))
+    {
+      /* Paranoia */
+      assert (node->info);
+      hdrp = (struct bfd_addrtreehdr *) node->info;
+      assert (hdrp->info);
+      assert (hdrp->count);
+
+      if ((subnode = route_node_lookup (hdrp->info, &cneighp->laddr)))
+	{
+	  /* Tuple raddr/laddr has been found, proceede to remove client from "clients" list */
+	  assert (subnode->info);
+	  for (ALL_LIST_ELEMENTS_RO
+	       (((struct bfd_cneigh *) subnode->info)->clients, listnode,
+		zservp))
+	    if (client == zservp)
+	      {
+		/* Found client - try to remove it from the list */
+		listnode_delete (((struct bfd_cneigh *) subnode->info)->
+				 clients, zservp);
+		/* Check if candidate neighbor was registered by any other client if 
+		   not remove the whole subnode i.e. (laddr) */
+		if (listcount (((struct bfd_cneigh *) subnode->info)->clients)
+		    == 0)
+		  {
+		    /* Proceed to remove laddr (subnode) */
+		    ///list_free(((struct bfd_cneigh *)subnode->info)->clients);
+		    zsend_bfd_cneigh_del (cneighp);	/* send update to bfdd */
+		    bfd_cneigh_free (subnode->info);
+		    subnode->info = NULL;
+		    subnode->lock = 0;
+		    route_node_delete (subnode);
+		    hdrp->count--;
+
+		    /* Check if any local address is attached to peer address, 
+		       if not remove the peer addr node */
+		    if (hdrp->count == 0)
+		      {
+			if (IS_ZEBRA_DEBUG_EVENT)
+			  zlog_debug ("%s: removing node", __func__);
+			bfd_addrtreehdr_free (node->info);
+			node->info = NULL;
+			node->lock = 0;
+			route_node_delete (node);
+		      }
+		  }
+		return 0;
+	      }
+	  /* Client not found */
+	  if (IS_ZEBRA_DEBUG_EVENT)
+	    zlog_debug ("%s: client not found", __func__);
+	  return -1;
+	}
+      /* laddr not found */
+      if (IS_ZEBRA_DEBUG_EVENT)
+	zlog_debug ("%s: laddr not found", __func__);
+      return -2;
+    }
+  else
+    {
+      /* raddr not found */
+      if (IS_ZEBRA_DEBUG_EVENT)
+	zlog_debug ("%s: raddr not found", __func__);
+      return -3;
+    }
+}
+
+int
+zread_ipv4_bfd_cneigh_del (struct zserv *client, u_short length)
+{
+  int ret;
+  struct bfd_cneigh *cneighp = zread_ipv4_bfd_cneigh_extract (client);
+  ret =
+    zread_bfd_cneigh_del (client, cneightbl->v4, cneighp,
+			  &zsend_ipv4_bfd_cneigh_del);
+  bfd_cneigh_free (cneighp);
+  return ret;
+}
+
+#ifdef HAVE_IPV6
+int
+zread_ipv6_bfd_cneigh_del (struct zserv *client, u_short length)
+{
+  int ret;
+  struct bfd_cneigh *cneighp = zread_ipv6_bfd_cneigh_extract (client);
+  ret =
+    zread_bfd_cneigh_del (client, cneightbl->v6, cneighp,
+			  &zsend_ipv6_bfd_cneigh_del);
+  bfd_cneigh_free (cneighp);
+  return ret;
+}
+#endif /* HAVE_IPV6 */
+
+/* Process Up message */
+static int
+zread_bfd_neigh_up (struct zserv *client, struct route_table *cneightable,
+		    struct bfd_cneigh *cneighp,
+		    int (*zsend_bfd_neigh_up) (struct zserv *,
+					       struct bfd_cneigh *))
+{
+  struct route_node *node, *subnode;
+  struct listnode *listnode;
+  struct zserv *zservp;
+  struct bfd_addrtreehdr *hdrp;
+
+  if ((node = route_node_lookup (cneightable, &cneighp->raddr)))
+    {
+      /* Paranoia */
+      assert (node->info);
+      hdrp = (struct bfd_addrtreehdr *) node->info;
+      assert (hdrp->info);
+      assert (hdrp->count);
+
+      if ((subnode = route_node_lookup (hdrp->info, &cneighp->laddr)))
+	{
+	  /* Tuple raddr/laddr has been found */
+	  assert (subnode->info);
+
+	  /* Notify registered clients about the state change to "Up" */
+	  for (ALL_LIST_ELEMENTS_RO
+	       (((struct bfd_cneigh *) subnode->info)->clients, listnode,
+		zservp))
+	    {
+	      if (client == zservp)	/* We don't want to notify ourselves */
+		continue;
+	      else
+		zsend_bfd_neigh_up (zservp, cneighp);
+	    }
+	  /* Client not found */
+	  if (IS_ZEBRA_DEBUG_EVENT)
+	    zlog_debug ("%s: client not found", __func__);
+	  return -1;
+	}
+      /* laddr not found */
+      if (IS_ZEBRA_DEBUG_EVENT)
+	zlog_debug ("%s: laddr not found", __func__);
+      return -2;
+    }
+  else
+    {
+      /* raddr not found */
+      if (IS_ZEBRA_DEBUG_EVENT)
+	zlog_debug ("%s: raddr not found", __func__);
+      return -3;
+    }
+  return 0;
+}
+
+int
+zread_ipv4_bfd_neigh_up (struct zserv *client, u_short length)
+{
+  int ret;
+  struct bfd_cneigh *cneighp = zread_ipv4_bfd_cneigh_extract (client);
+  ret =
+    zread_bfd_neigh_up (client, cneightbl->v4, cneighp,
+			&zsend_ipv4_bfd_neigh_up);
+  bfd_cneigh_free (cneighp);
+  return ret;
+}
+
+#ifdef HAVE_IPV6
+int
+zread_ipv6_bfd_neigh_up (struct zserv *client, u_short length)
+{
+  int ret;
+  struct bfd_cneigh *cneighp = zread_ipv6_bfd_cneigh_extract (client);
+  ret =
+    zread_bfd_neigh_up (client, cneightbl->v6, cneighp,
+			&zsend_ipv6_bfd_neigh_up);
+  bfd_cneigh_free (cneighp);
+  return ret;
+}
+#endif /* HAVE_IPV6 */
+
+/* Process Down message */
+static int
+zread_bfd_neigh_down (struct zserv *client, struct route_table *cneightable,
+		      struct bfd_cneigh *cneighp,
+		      int (*zsend_bfd_neigh_down) (struct zserv *,
+						   struct bfd_cneigh *))
+{
+  struct route_node *node, *subnode;
+  struct listnode *listnode;
+  struct zserv *zservp;
+  struct bfd_addrtreehdr *hdrp;
+
+  if ((node = route_node_lookup (cneightable, &cneighp->raddr)))
+    {
+      /* Paranoia */
+      assert (node->info);
+      hdrp = (struct bfd_addrtreehdr *) node->info;
+      assert (hdrp->info);
+      assert (hdrp->count);
+
+      if ((subnode = route_node_lookup (hdrp->info, &cneighp->laddr)))
+	{
+	  /* Tuple raddr/laddr has been found */
+	  assert (subnode->info);
+
+	  /* Notify registered clients about the state change to "Down" */
+	  for (ALL_LIST_ELEMENTS_RO
+	       (((struct bfd_cneigh *) subnode->info)->clients, listnode,
+		zservp))
+	    {
+	      if (client == zservp)	/* We don't want to notify ourselves */
+		continue;
+	      else
+		zsend_bfd_neigh_down (zservp, cneighp);
+	    }
+	  /* Client not found */
+	  if (IS_ZEBRA_DEBUG_EVENT)
+	    zlog_debug ("%s: client not found", __func__);
+	  return -1;
+	}
+      /* laddr not found */
+      if (IS_ZEBRA_DEBUG_EVENT)
+	zlog_debug ("%s: laddr not found", __func__);
+      return -2;
+    }
+  else
+    {
+      /* raddr not found */
+      if (IS_ZEBRA_DEBUG_EVENT)
+	zlog_debug ("%s: raddr not found", __func__);
+      return -3;
+    }
+  return 0;
+}
+
+int
+zread_ipv4_bfd_neigh_down (struct zserv *client, u_short length)
+{
+  int ret;
+  struct bfd_cneigh *cneighp = zread_ipv4_bfd_cneigh_extract (client);
+  ret =
+    zread_bfd_neigh_down (client, cneightbl->v4, cneighp,
+			  &zsend_ipv4_bfd_neigh_down);
+  bfd_cneigh_free (cneighp);
+  return ret;
+}
+
+#ifdef HAVE_IPV6
+int
+zread_ipv6_bfd_neigh_down (struct zserv *client, u_short length)
+{
+  int ret;
+  struct bfd_cneigh *cneighp = zread_ipv6_bfd_cneigh_extract (client);
+  ret =
+    zread_bfd_neigh_down (client, cneightbl->v6, cneighp,
+			  &zsend_ipv6_bfd_neigh_down);
+  bfd_cneigh_free (cneighp);
+  return ret;
+}
+#endif /* HAVE_IPV6 */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/zebra/zserv_bfd.h quagga-0.99.9-bfd-0.90.1/zebra/zserv_bfd.h
--- quagga-0.99.9/zebra/zserv_bfd.h	1970-01-01 01:00:00.000000000 +0100
+++ quagga-0.99.9-bfd-0.90.1/zebra/zserv_bfd.h	2007-10-21 01:09:15.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * ZEBRA - zserv_bfd.h   
+ *
+ * Copyright (C) 2007   Jaroslaw Adam Gralak
+ *
+ * This program is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU General Public Licenseas published by the Free 
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,but WITHOUT 
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+ * more details.
+
+ * You should have received a copy of the GNU General Public License along 
+ * with this program; if not, write to the Free Software Foundation, Inc., 
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef _ZEBRA_ZSERV_BFD_H
+#define _ZEBRA_ZSERV_BFD_H
+
+void bfd_cneigh_init (void);
+
+int zread_bfd_register (struct zserv *client, u_short length);
+
+int zread_ipv4_bfd_cneigh_list (struct zserv *client, u_short length);
+int zread_ipv4_bfd_cneigh_add (struct zserv *client, u_short length);
+int zread_ipv4_bfd_cneigh_del (struct zserv *client, u_short length);
+int zread_ipv4_bfd_neigh_up (struct zserv *client, u_short length);
+int zread_ipv4_bfd_neigh_down (struct zserv *client, u_short length);
+#ifdef HAVE_IPV6
+int zread_ipv6_bfd_cneigh_list (struct zserv *client, u_short length);
+int zread_ipv6_bfd_cneigh_add (struct zserv *client, u_short length);
+int zread_ipv6_bfd_cneigh_del (struct zserv *client, u_short length);
+int zread_ipv6_bfd_neigh_up (struct zserv *client, u_short length);
+int zread_ipv6_bfd_neigh_down (struct zserv *client, u_short length);
+#endif /* HAVE_IPV6 */
+
+#endif /*_ZEBRA_ZSERV_BFD_H */
diff -Nupwbr --exclude=bgpd quagga-0.99.9/zebra/zserv.c quagga-0.99.9-bfd-0.90.1/zebra/zserv.c
--- quagga-0.99.9/zebra/zserv.c	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/zebra/zserv.c	2007-10-21 01:09:15.000000000 +0200
@@ -38,11 +38,13 @@
 #include "buffer.h"
 
 #include "zebra/zserv.h"
+#include "zebra/zserv_bfd.h"
 #include "zebra/router-id.h"
 #include "zebra/redistribute.h"
 #include "zebra/debug.h"
 #include "zebra/ipforward.h"
 
+
 /* Event list of zebra. */
 enum event { ZEBRA_SERV, ZEBRA_READ, ZEBRA_WRITE };
 
@@ -92,7 +94,7 @@ zserv_flush_data(struct thread *thread)
   return 0;
 }
 
-static int
+int
 zebra_server_send_message(struct zserv *client)
 {
   if (client->t_suicide)
@@ -121,7 +123,7 @@ zebra_server_send_message(struct zserv *
   return 0;
 }
 
-static void
+void
 zserv_create_header (struct stream *s, uint16_t cmd)
 {
   /* length placeholder, caller can update */
@@ -653,6 +655,9 @@ zsend_ipv4_import_lookup (struct zserv *
   return zebra_server_send_message(client);
 }
 
+
+
+
 /* Router-id is updated. Send ZEBRA_ROUTER_ID_ADD to client. */
 int
 zsend_router_id_update (struct zserv *client, struct prefix *p)
@@ -1283,6 +1288,41 @@ zebra_client_read (struct thread *thread
     case ZEBRA_IPV4_IMPORT_LOOKUP:
       zread_ipv4_import_lookup (client, length);
       break;
+    case ZEBRA_BFD_REGISTER:
+      zread_bfd_register (client, length);
+      break;
+    case ZEBRA_IPV4_BFD_CNEIGH_LIST:
+      zread_ipv4_bfd_cneigh_list (client, length);
+      break;
+    case ZEBRA_IPV4_BFD_CNEIGH_ADD:
+      zread_ipv4_bfd_cneigh_add (client, length);
+      break;
+    case ZEBRA_IPV4_BFD_CNEIGH_DEL:
+      zread_ipv4_bfd_cneigh_del (client, length);
+      break;
+    case ZEBRA_IPV4_BFD_NEIGH_UP:
+      zread_ipv4_bfd_neigh_up (client, length);
+      break;
+    case ZEBRA_IPV4_BFD_NEIGH_DOWN:
+      zread_ipv4_bfd_neigh_down (client, length);
+      break;
+#ifdef HAVE_IPV6
+    case ZEBRA_IPV6_BFD_CNEIGH_LIST:
+      zread_ipv6_bfd_cneigh_list (client, length);
+      break;
+    case ZEBRA_IPV6_BFD_CNEIGH_ADD:
+      zread_ipv6_bfd_cneigh_add (client, length);
+      break;
+    case ZEBRA_IPV6_BFD_CNEIGH_DEL:
+      zread_ipv6_bfd_cneigh_del (client, length);
+      break;
+    case ZEBRA_IPV6_BFD_NEIGH_UP:
+      zread_ipv6_bfd_neigh_up (client, length);
+      break;
+    case ZEBRA_IPV6_BFD_NEIGH_DOWN:
+      zread_ipv6_bfd_neigh_down (client, length);
+      break;
+#endif /* HAVE_IPV6 */
     default:
       zlog_info ("Zebra received unknown command %d", command);
       break;
diff -Nupwbr --exclude=bgpd quagga-0.99.9/zebra/zserv.h quagga-0.99.9-bfd-0.90.1/zebra/zserv.h
--- quagga-0.99.9/zebra/zserv.h	2007-10-21 17:04:17.000000000 +0200
+++ quagga-0.99.9-bfd-0.90.1/zebra/zserv.h	2007-10-21 01:09:15.000000000 +0200
@@ -82,6 +82,7 @@ struct zebra_t
   struct work_queue *ribq;
 };
 
+
 /* Count prefix size from mask length */
 #define PSIZE(a) (((a) + 7) / (8))
 
@@ -105,6 +106,8 @@ extern int zsend_interface_update (int, 
 extern int zsend_route_multipath (int, struct zserv *, struct prefix *, 
                                   struct rib *);
 extern int zsend_router_id_update(struct zserv *, struct prefix *);
+extern int zebra_server_send_message(struct zserv *client);
+extern void zserv_create_header (struct stream *s, uint16_t cmd);
 
 extern pid_t pid;
 extern pid_t old_pid;
